---
title: CS-210 Functional Programming Principles in Scala
description: "My notes from the CS-210 course at EPFL, fall semester 2016: Functional Programming Principles in Scala"
image: /images/hero/epfl-bc.jpg
fallback-color: "#4a4c45"
unlisted: true
edited: true
---

* TOC
{:toc}

## Books
- [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sicp/full-text/book/book.html), Harold Abelson and Gerald Jay Sussman, MIT Press
- Programming in Scala, Martin Odersky, Lex Spoon and Bill Venners, 2nd edition, Artima 2010

## Call-by-name (CBN), call-by-value (CBV)
Let's say we have the following function, and that we call it in the following way:

{% highlight scala linenos %}
def test(x: Int, y: int) = x * x

test(3+4, 2)
{% endhighlight %}

There are 2 strategies to solving this: send the function the uncalculated arguments (CBN) or calculate the arguments and *then* send them to the function (CBV). 


- CBN and CBV reduce an expression to the same value as long as both evaluations terminate.
- If CBV evaluation of an expression *e* terminates, then CBN evaluation of *e* terminates too
- The other direction is not true.

Here's an example:

{% highlight scala linenos %}
def first(x: Int, y: Int) = x
def loop: Int = loop

first(1, loop) // reduces to 1 under CBN since loop isn't run
first(1, loop) // does not terminate under CBV
{% endhighlight %}

Scala normally uses CBV, but you can force CBN with the `=>`.

{% highlight scala linenos %}
def contOne(x: Int, y: => Int) = 1

def or(x: Boolean, y: => Boolean) = if (x) y else false // we need to return y as a value, not a function.
{% endhighlight %}

### Value definitions
Using `def` is CBN, but `val` is CBV.

{% highlight scala linenos %}
val x = 2 // x refers to 2
val y = square(x) // y refers to 4, and not the function square(x)

def x = loop // OK
val x = loop // does not terminate since loop is evaluated
{% endhighlight %}


## Blocks and lexical scope
To avoid namespace pollution, we can use nested functions:

{% highlight scala linenos %}
def sqrt(x: Double) = {
    def sqrtIter(guess: Double): Double =
        if (isGoodEnough(guess)) guess
        else sqrtIter(improve(guess))

    def isGoodEnough(guess: Double) =
        abs(guess * guess - x) / x < 0.001

    def improve(guess: Double) =
        (guess + x / guess) / 2

    sqrtIter(1.0)
}
{% endhighlight %}

This is done using a block, delimited by `{ ... }` braces. The last element of a block is an expression that defines its return value.

The definitions inside a block are only visible from within the block. The block has access to what's been defined outside of it, but if it redefines an external definition, the new one will *shadow* the old one, meaning it will be redefined inside the block.

## Tail recursion
If a function calls itself as its last action, then the function's stack frame can be reused. This is called *tail recursion*. In practice, this means that recursion is iterative in Scala, and is just as efficient as a loop.

One can require that a function is tail-recursive using a `@tailrec` annotation:

{% highlight scala linenos %}
@tailrec
def gcd(a: Int, b:Int): Int = ...
{% endhighlight %}

An error is issued if `gcd` isn't tail recursive.

## Higher-Order Functions
Functions that take other functions as parameters or that return functions as results are called *higher order functions*, as opposed to a *first order function* that acts on simple data types.

{% highlight scala linenos %}
// Higher order function
// Corresponds to the sum of f(n) from a to b
def sum(f: Int => Int, a: Int, b: Int): =
    if (a > b) 0
    else f(a) + sum(f, a + 1, b)

// Different functions f
def id(x: Int): Int = x
def cube(x: Int): Int = x * x * x

// Calling our higher order function
def sumInts(a: Int, b: Int): Int = sum(id, a, b)
def sumCubes(a: Int, b: Int): Int = sum(cube, a, b)
{% endhighlight %}

### Anonymous functions
Instead of having to define a `cube` and `id` function in the example above, we can just write an anonymous function as such:

{% highlight scala linenos %}
def sumInts(a: Int, b:Int): Int = sum(x => x, a, b)
def sumCubes(a: Int, b: Int): Int = sum(x => x*x*x, a, b)
{% endhighlight %}

## Currying
From [Wikipedia](https://en.wikipedia.org/wiki/Currying):

> Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument.

Essentially, with currying we do the following transition:

{% highlight scala linenos %}
def f(x: Int): Int = x + y
f(1, 2) // evaluates to 3

def curry(f: (Int, Int) => Int): Int => (Int => Int) = x => y => f(x, y)
curry(f) // evaluates to x => (y => x + y)
curry(f)(1) // evaluates to y => y + 1
curry(f)(1)(2) // evaluates to 3
{% endhighlight %}

Using currying, we can once more improve our `sum` function:

{% highlight scala linenos %}
def sum(f: Int => Int): (Int, Int) => Int = { // Higher order function
    def sumF(a: Int, b: Int): Int =
        if (a > b) 0
        else f(a) + sumF(a + 1, b)
    sumF // Returns another function
}

sum(cube)(1, 10) // equivalent to sumCubes

// Syntactic sugar:
def sum(f: Int => Int)(a: Int, b: Int): Int =
    if (a > b) 0 else f(a) + sum(f)(a+1, b)
{% endhighlight %}

*Function application associates to the left* so `sum(cube)(1, 10)` is equivalent to `(sum(cube))(1, 10)`.

The type of `sum` is `(Int => Int) => (Int, Int) => Int`. This should be read and understood as `(Int => Int) => ((Int, Int) => Int)` as *functional types associate to the right*.

## Classes: functions and data
In Scala, we use *classes* to define and create data structures:

{% highlight scala linenos %}
class Rational(x: Int, y: Int) {
    def numer = x
    def denom = y
}

val x = new Rational(1, 2)
{% endhighlight %}

This introduces two entities:

- A new *type* named `Rational`
- A *constructor* `Rational` to create elements of this type

### Methods
One can go further and also package functions operating on a data abstraction into the data abstraction itself. Such functions are called *methods*.

{% highlight scala linenos %}
class Rational(x: Int, y: Int) {
    def numer = x 
    def denom = y

    def add(that: Rational) = 
        new Rational(
            numer * that.denom + that.numer * denom,
            denom * that.denom)

    override def toString = numer + "/" + denom
}
{% endhighlight %}

#### Identifier

The identifier is alphanumeric (starting with a letter, followed by letters or numbers) xor symbolic (starting with a symbol, followed by other symbols). We can mix them by using an alphanumeric name, an underscore `_` and then a symbol.

Small practical trick: to define a `neg` function that returns the negation of a `Rational`, we can write:

{% highlight scala linenos %}
class Rational(x: Int, y: Int) {
    ...

    def unary_- : Rational = new Rational(-numer, denom) // space between - and : because : shouldn't be a part of the identifier.
}
{% endhighlight %}

The *precedence* of an operator is determined by its first character, in the following priority (from lowest to highest):

- All letters
- `|`
- `^`
- `&`
- `< >`
- `= !`
- `:`
- `+ -`
- `* / %`
- All other symbolic characters

#### Infix notation
Any method with a parameter can be used like an infix operator:

{% highlight scala linenos %}
r add s                            r.add(s)
r less s     /* in place of */     r.less(s)
r max s                            r.max(s)
{% endhighlight %}

### Constructors
Scala naturally executes the code in the class body as an implicit constructor, but there is a way to explicitly define more constructors if necessary:

{% highlight scala linenos %}
class Rational(x: Int, y: Int) {
    def this(x: Int) = this(x, 1)

    def numer = x
    def denom = y
}
{% endhighlight %}

### Data abstraction
We can improve `Rational` by making it an irreducible fraction using the GCD:

{% highlight scala linenos %}
class Rational(x: Int, y: Int) {
    private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
    val numer = x / gcd(x, y) // Computed only once with a val
    val denom = y / gcd(x, y)

    ...
}
{% endhighlight %}

There are obviously multiple ways of achieving this; the above code just shows one. The ability to choose different implementations of the data without affecting clients is called *data abstraction*.

### Assert and require
When calling the constructor, using a denominator of 0 will eventually lead to errors. There are two ways of imposing restrictions on the given constructor arguments:

- `require`, which throws an `IllegalArgumentException` if it fails
- `assert`, which throws an `AssertionError` if it fails

This reflects a difference in intent:

- `require` is used to enforce a precondition on the caller of a function
- `assert` is used to check the code of the function itself

{% highlight scala linenos %}
class Rational(x: Int, y: Int) {
    require(y != 0, "denominator must be non-zero")
    
    val root = sqrt(this)
    assert(root >= 0)
}
{% endhighlight %}

## Class Hierarchies

### Abstract classes
Just like in [Java](/notes-prog/), we can have absctract classes and their implementation:
 
{% highlight scala linenos %}
abstract class IntSet {
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
}

class Empty extends IntSet { // Empty binary tree
    def contains(x: Int): Boolean = false
    def incl(x: Int): IntSet = new NonEmpty(x, new Empty, new Empty)
}

class NonEmpty(elem: Int, left: IntSet, right: Intset) extends IntSet { // left and right subtree
    def contains(x: Int): Boolean =
        if (x < elem) left contains x
        else if (x > elem) right contains x
        else true

    def incl(x: Int): IntSet = 
        if (x < elem) new NonEmpty(elem, left incl x, right)
        if (x > elem) new NonEmpty(elem, left, right incl x)
        else this // already in the tree, nothing to add
}
{% endhighlight %}

#### Terminology
- `Empty` and `NonEmpty` both *extend* the class `IntSet`
- The definitions of `incl` and `contains` *implement* the abstract functions of `IntSet`
- This implies that the types `Empty` and `NonEmpty` *conform* to the type `IntSet`, and can be used wherever an `IntSet` is required
- `IntSet` is the superclass of `Empty` and `NonEmpty`
- `Empty` and `NonEmpty` are *subclasses* of `IntSet`
- In Scala, any user-defined class extends another class. By default, if no superclass is given, the superclass is `Object`
- The direct or indirect superclasses are called *base classes*

#### Override
It is possible to *redefine* an existing, non-abstract definition in a subclass by using `override`.

{% highlight scala linenos %}
abstract class Base {
    def foo = 1
    def bar: Int
}

class Sub extends Base {
    override def foo = 2 // You need to use override
    def bar = 3
}
{% endhighlight %}

Overriding something that isn't overrideable yields an error. 

### Traits
In Scala, a class can only have one superclass. But sometimes we want several supertypes. To do this we can use *traits*. It's declared just like an abstract class, but using the keyword `trait`:

{% highlight scala linenos %}
trait Planar {
    def height: Int // Abstract method as it lacks an implementation
    def width: Int
    def surface = height * width // Concrete method defining a default implementation
}
{% endhighlight %}

Classes, objects and traits can inherit from at most one class but as arbitrarily many traits.

{% highlight scala linenos %}
class Square extends Shape with Planar with Movable ...
{% endhighlight %}

Traits **cannot** have value parameters, only classes can.

### Singleton objects
In the `IntSet` example, one could argue that there really only is a single empty `IntSet`, and that it's overkill to have the user create many instances of `Empty`. Instead we can define a *singleton object*:

{% highlight scala linenos %}
object Empty extends IntSet {
    def contains(x: Int): Boolean = false
    def incl(x: Int): IntSet = new NonEmpty(x, Empty, Empty)
}
{% endhighlight %}

Singleton objects are values, so `Empty` evaluates to itself.

### Packages and imports
Classes and objects are organized in packages, just like in Java. 

{% highlight scala linenos %}
package funprog.example

object Rational {
    ...
}
{% endhighlight %}

One can now call the object using its full qualified name, or with an import:

{% highlight scala linenos %}
object test {
    new funprog.example.Rational(1, 2)
}

// or
import funprog.example.Rational // Import Rational
import funprog.example.{Rational, Hello} // Import both Rational and Hello
import funprog.example._ // Or import everything in funprog.example

object test2 {
    new Rational(1, 2)
}
{% endhighlight %}

### Polymorphism
Just [like in Java](/notes-prog#gnricithttpcs108epflcharchive15filesppo1502genericitepdf), we may wish to have polymorphic types. 

{% highlight scala linenos %}
trait List[T] {
    def isEmpty: Boolean
    def head: T
    def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
    def isEmpty = false

    // val head: T is a legal implementation of head
    // and so is val tail: List[T]
    // (they're in the argument list of Cons[T])
}

class Nil[T] extends List[T] {
    def isEmpty = true
    def head = throw new NoSuchElementException("Nil.head")
    def tail = throw new NoSuchElementException("Nil.tail") // returns type Nothing
}
{% endhighlight %}

Type parameters can be used in classes, but also in functions.

#### Type inference
The Scala compiler can usually deduce the correct type parameters.

{% highlight scala linenos %}
def singleton[T](elem: T) = new Cons[T](elem, new Nil[T])

singleton[Int](1) // Explicit type definition
singleton(1) // Type inference
{% endhighlight %}
