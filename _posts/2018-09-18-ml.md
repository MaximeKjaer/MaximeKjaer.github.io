---
title: CS-443 Machine Learning
description: "My notes from the CS-443 Machine Learning course given at EPFL, in the 2018 autumn semester (MA1)"
edited: true
note: true
---

* TOC
{:toc}

⚠ *Work in progress*

<!-- More --> 

We'll always use subscript $n$ for data point, and $d$ for feature. $N$ is the data size and $D$ is the dimensionality.

Recommended website: <http://www.matrixcalculus.org/>

## Linear regression
A linear regression is a model that assumes a linear relationship between inputs and the output. We will study three types of methods:

1. Grid search
2. Iterative optimization algorithms
3. Least squares

### Simple linear regression

For a single input dimension ($D=1$), we can use a simple linear regression, which is given by:

$$
\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\expect}[1]{\mathbb{E}\left[#1\right]}
\newcommand{\expectsub}[2]{\mathbb{E}_{#1}\left[#2\right]}

y_n \approx f(x_n) := w_0 + w_1 x_{n1}
$$

$w = (w_0, w_1)$ are the parameters of the model.

### Multiple linear regression

If our data has multiple input dimensions, we obtain multivariate linear regression:

$$
y_n \approx 
    f(\pmb{x}_n) :=w_0 + w_1x_{n1}+\dots+w_D x_{wD} 
    = w_0 + \pmb{x}_n^t \begin{bmatrix}
        w_1 \\
        \vdots \\
        w_D \\
    \end{bmatrix}
    = \tilde{\pmb{x}}_n ^T \tilde{\pmb{w}}
$$

> 👉🏼 If we wanted to be a little more strict, we should write $f_{\pmb{w}}(\pmb{x}_n)$, as the model of course also depends on the weights.

The tilde notation means that we have included the offset term $w_0$, also known as the **bias**:

$$
\tilde{\pmb{x}}_n=\begin{bmatrix}1 \\ x_{n1} \\ \vdots \\ x_{nD} \end{bmatrix} \in \mathbb{R}^{D+1}, 
\quad
\tilde{\pmb{w}} = \begin{bmatrix}w_0 \\ w_1 \\ \vdots \\ w_D\end{bmatrix} \in \mathbb{R^{D+1}}
$$

### The $D > N$ problem

If the number of parameters exceeds the number of data examples, we say that the task is *under-determined*. This can be solved by regularization, which we’ll get to more precisely later

## Cost functions

$\pmb{x}_n$ is the data, which we can easily understand where comes from. But how does one find a good $\pmb{w}$ from the data? 

A **cost function** (also called loss function) is used to learn parameters that explain the data well. It quantifies how well our model does by giving errors a score, quantifying penalties for errors. Our goal is to find weights that minimize the loss functions.

### Properties

Desirable properties of cost functions are:

- **Symmetry around 0**: that is, being off by a positive or negative amount is equivalent; what matters is the amplitude of the error, not the sign.
- **Robustness**: penalizes large errors at about the same rate as very large errors. This is a way to make sure that outliers don’t completely dominate our regression.

### Good cost functions

#### MSE

Probably the most commonly used cost function is Mean Square Error (MSE): 

$$
\mathcal{L}_{\text{MSE}}(\pmb{w}) := \frac{1}{N} \sum_{n=1}^N \left(y_n - f(\pmb{x}_n)\right)^2
\label{def:mse}
$$

MSE is symmetrical aroudn 0, but also tends to penalize outliers quite harshly (because it squares error): MSE is not robust. In practice, this is problematic, because outliers occur more often than we’d like to.

Note that we often use MSE with a factor $\frac{1}{2N}$ instead of $\frac{1}{N}$. This is because it makes for a cleaner derivative, but we'll get into that later. Just know that for all intents and purposes, it doesn't change really change anything about the behavior of the models we'll study.

#### MAE

When outliers are present, Mean Absolute Error (MAE) tends to fare better:

$$
\text{MAE}(\pmb{w}) := \frac{1}{N} \sum_{n=1}^N \left| y_n - f(\pmb{x}_n)\right|
$$

Instead of squaring, we take the absolute value. This is more robust. Note that MAE isn’t differentiable at 0, but we’ll talk about that later.

There are other cost functions that are even more robust; these are available as additional reading, but is not exam material.

### Convexity

A function is **convex** iff a line joining two points never intersects with the function anywhere else. More strictly defined, a function $f(\pmb{u})$ with $\pmb{u}\in\chi$ is *convex* if, for any $\pmb{u}, \pmb{v} \in\chi$, and for any $0 \le\lambda\le 1$, we have:

$$
f(\lambda\pmb{u}+(1-\lambda)\pmb{v})\le\lambda f(\pmb{u}) +(1-\lambda)f(\pmb{v})
$$

A function is **strictly convex** if the above inequality is strict ($<$).

A stritly convex function has a unique global minimum $\pmb{w}^*$. For convex functions, every local minimum is a global minimum. This makes it a desirable property for loss functions, since it means that cost function optimization is guaranteed to find the global minimum.

Sums of convex functions are also convex. Therefore, MSE and MAE are convex.

## Optimization

### Learning / Estimation / Fitting

Given a cost function (or loss function) $\mathcal{L}(\pmb{w})$, we wish to find $\pmb{w}^*$ which minimizes the cost:

$$
\min_{\pmb W}{\mathcal{L}(\pmb w)}, \quad\text{ subject to } \pmb w \in \mathbb R^D
$$

This is what we call **learning**: learning is simply an optimization problem, and as such, we’ll use an optimization algorithm to solve it – that is, find a good $\pmb w$.

### Grid search

This is one of the simplest optimization algorithms, although far from being the most efficient one. It can be described as “try all the values”, a kind of brute-force algorithm; you can think of it as nested for-loops over the individual $w_i$ weights.

For instance, if our weights are $\pmb{w} = \begin{bmatrix}w_1 \\ w_2\end{bmatrix}$, then we can try, say 4 values for $w_1$, 4 values for $w_2$, for a total of 16 values of $\mathcal{L}(\pmb{w})$.

But obviously, complexity is exponential $\mathcal{O}(a^D)$ (where $a$ is the number of values to try), which is really bad, especially when we can have $D\approx$ millions of parameters. Additionally, grid search has no guarantees that it’ll find an optimum; it’ll just find the best value we tried.

If grid search sounds bad for optimization, that’s because it is. In practice, it is not used for optimization of parameters, but it *is* used to tune hyperparameters.

### Optimization landscapes

#### Local minimum

A vector $\pmb{w}^\*$ is a *local minimum* of a function $\mathcal{L}$ (we’re interested in the minimum of cost functions $\mathcal{L}$, which we denote with $\pmb{w}^*$, as opposed to any other value $\pmb{w}$, but this obviously holds for any function) if $\exists \epsilon > 0$ such that

$$
\mathcal{L}(\pmb{w}^*) \le \mathcal{L(\pmb{w})}, \quad \forall\pmb w : \norm{\pmb{w} -\pmb{w}^*} < \epsilon
$$

In other words, the local minimum $\pmb{w}^*$ is better than all the neighbors in some non-zero radius.

#### Global minimum

The global minimum is defined by getting rid of the radius $\epsilon$ and comparing to all other values:

$$
\mathcal{L}(\pmb{w}^*) \le \mathcal{L(\pmb{w})}, \qquad \forall\pmb{w}\in\mathbb{R}^D
$$

#### Strict minimum

A minimum is said to be **strict** if the corresponding equality is strict for $\pmb{w} \ne \pmb{w}^*$, that is, there is only one minimum value.

### Smooth (differentiable) optimization

#### Gradient

A gradient at a given point is the slope of the tangent to the function at that point. It points to the direction of largest increase of the function. By following the gradient (in the opposite direction, because we’re searching for a minimum and not a maximum), we can find the minimum.

![Graphs of MSE and MAE](/images/ml/mse-mae.png)

Gradient is defined by:

$$
\nabla \mathcal{L}(\pmb{w}) := \begin{bmatrix}
	\frac{\partial\mathcal{L}(\pmb{w})}{\partial w_1} \\
	\vdots \\
	\frac{\partial\mathcal{L}(\pmb{w})}{\partial w_D} \\
\end{bmatrix}
$$

This is a vector, i.e. $\nabla\mathcal{L}(\pmb{w})\in\mathbb R^D$. Each dimension $i$ of the vector indicates how fast the cost $\mathcal{L}$ changes depending on the weight $w_i$.

#### Gradient descent

Gradient descent is an iterative algorithm. We start from a candidate $w^{(t)}$, and iterate.

$$
\pmb{w}^{(t+1)}:=\pmb{w}^{(t)} - \gamma \nabla\mathcal{L}\left(\pmb{w}^{(t)}\right)
$$

As stated previously, we’re adding the negative gradient to find the minimum, hence the substraction.

$\gamma$ is known as the **step-size**, which is a small value (maybe 0.1). You don’t want to be too aggressive with it, or you might risk overshooting in your descent. In practice, the step-size that makes the learning as fast as possible is often found by trial and error 🤷🏼‍♂️.

As an example, we will take an analytical look at a gradient descent, in order to understand its behavior and components. We will do gradient descent on a 1-parameter model, in which we minimize the MSE, which is defined as follows:

$$
\mathcal{L}\left(w_0\right)=\frac{1}{2N}\sum_{n=1}^N{\left(y_n - w_0\right)^2}
$$

Note that we’re dividing by 2 on top of the regular MSE; it has no impact on finding the minimum, but when we will compute the gradient below, it will conveniently cancel out the $\frac{1}{2}$.

The gradient of $\mathcal{L}\left(w_0\right)$ is:

$$
\begin{align}
\nabla\mathcal{L}\left(\pmb{w}\right)
	& = \frac{\partial}{\partial w_0}\mathcal{L} \\
	& = \frac{1}{2N}\sum_{n=1}^N{-2(y_n - w_0)}  \\
	& = w_0 - \bar{y}
\end{align}
$$

And thus, our gradient descent is given by:

$$
\begin{align*}
w_0^{(t+1)}
	&:= w_0^{(t)} - \gamma\nabla\mathcal{L}\left(\pmb w\right) \\
	& = w_0^{(t)} - \gamma(w_0^{(t)} - \bar{y}) \\
	& = (1-\gamma)w_0^{(t)} + \gamma\bar{y}, 
	\qquad\text{where } \bar{y}:=\sum_{n}{\frac{y_n}{N}}
\end{align*}
$$

This sequence is guaranteed to converge for $\pmb{w}^* = \bar{y}$ (so the solution to this exact problem can be extracted analytically from gradient descent). This would set the cost function to 0, which is the minimum.

The choice of $\gamma$ has an influence on the algorithm’s outcome:

- If we pick $\gamma=1$, we would get to the optimum in one step
- If we pick $\gamma < 1$, we would get a little closer in every step, eventually converging to $\bar{y}$
- If we pick $\gamma > 1$, we are going to overshoot $\bar{y}$. Slightly bigger than 1 (say, 1.5) would still converge; $\gamma=2$ would loop infinitely between two points; $\gamma > 2$ diverges.

#### Gradient descent for linear MSE

Our linear regression is given by a line $\pmb{y}$ that is a regression for some data $\pmb X$:

$$
\pmb{y}=\begin{bmatrix}
	y_1 \\ y_2 \\ \vdots \\ y_N
\end{bmatrix}, 
\quad
\pmb{X}=\begin{bmatrix}
x_{11} & x_{12} & \dots & x_{1D} \\
x_{21} & x_{22} & \dots & x_{2D} \\
\vdots & \vdots & \ddots & \vdots \\
x_{N1} & x_{N2} & \dots & x_{ND} \\
\end{bmatrix}
$$

Our model is:

$$
f_w(x)=\pmb{x}_n^T \pmb{w}
$$

We define the error vector by:

$$
\pmb{e}=\pmb{y} - \pmb{Xw}, 
\quad \text{ or } \quad 
\pmb{e}_n = \pmb{x}_n^T\pmb{w}
$$

The MSE can then be restated as follows:

$$
\mathcal{L}\left(\pmb{w}\right)
	:= \frac{1}{2N}\sum_{n=1}^N{\left( y_n - \pmb{x}_n^T \pmb{w}\right)^2}
	=  \frac{1}{2N}\pmb{e}^T\pmb{e}
$$

And the gradient is, component-wise:

$$
\frac{\partial}{\partial\pmb{w}_d}\mathcal{L}
	= -\frac{1}{2N}\sum_{n=1}^N {2(y_n - \pmb{x}_n^T \pmb{w}) \pmb{x}_{nd}}
	= -\frac{1}{N} (\pmb{X}_{:d})^T \pmb{e}
$$

We’re using column notation $\pmb{X}_{:d}$ to signify column $d$ of the matrix $X$.

And thus, all in all, our gradient is:

$$
\nabla\mathcal{L}\left(\pmb{w}\right) = -\frac{1}{N}\pmb{X}^T\pmb{e}
$$

To compute this expression, we must compute:

- The error $\pmb e$, which takes $2N\cdot D - 1$ floating point operations (flops) for the matrix-vector multiplication, and $N$ for the subtraction, for a total of $2N\cdot D + N - 1$, which is $\mathcal{O}(N\cdot D)$
- The gradient $\nabla\mathcal{L}$, which costs $2N\cdot D + D - 1$, which is $\mathcal{O}(N\cdot D)$.

In total, this process is $\mathcal{O}(N\cdot D)$ at every step. This is not too bad, it’s equivalent to reading the data once.

#### Stochastic gradient descent (SGD)

In ML, most cost functions are formulated as a sum of:

$$
\mathcal{L}\left(\pmb{w}\right) = \frac{1}{N}\sum_{n=1}^N{\mathcal{L}_n(\pmb{w})}
$$

In practice, this can be expensive to compute, so the solution is to pick a random $n$ uniformly at random in $n\in\left[1, N\right]$ to be able to make the sum go away.

The stochastic gradient descent is thus:

$$
\pmb{w}^{(t+1)}:=\pmb{w}^{(t)} - \gamma \nabla\mathcal{L}_n\left({\pmb{w}^{(t)}}\right)
$$

Why is it allowed to pick just one $n$ instead of the full thing? We won’t give a full proof, but the intuition is that:

$$
\expect{\nabla\mathcal{L}_n(\pmb{w})}
	= \frac{1}{N} \sum_{n=1}^N{\nabla\mathcal{L}_n(\pmb{w})}
	= \nabla\left(\frac{1}{N} \sum_{n=1}^N{\mathcal{L}_n(\pmb{w})}\right)
	\equiv \nabla\mathcal{L}\left(\pmb{w}\right)
$$

The gradient of a single n is:

$$
\mathcal{L}_n(\pmb{w}) = \frac{1}{2} \left(y_n -\pmb{x}_n^T w\right)^2 \\
\nabla\mathcal{L}_n(\pmb{w}) = (-x_n^T) (y_n-\pmb{x}_n^T \pmb{w})
$$

Note that $x_n^T \in\mathbb{R}^D$, and $(y_n-\pmb{x}_n^T \pmb{w})\in\mathbb{R}$. Computational complexity for this is $\mathcal{O}(D)$. 

#### Mini-batch SGD

But perhaps just picking a **single** value is too extreme; there is an intermediate version in which we choose a subset $B\subseteq \left[N\right]$ instead of $\abs{B}$ points, instead of a single point.

$$
g := \frac{1}{|B|}\sum_{n\in B}{\nabla\mathcal{L}_n(\pmb{w}^{(t)})} \\
w^{(t+1)} := w^{(t)} - \gamma\pmb{g}
$$

Note that if $\abs{B} = N$ then we’re performing a full gradient descent.

The computation of $\pmb{g}$ can be parallelized easily over $\abs{B}$ GPU threads, which is quite common in practice; $\abs{B}$ is thus often dictated by the number of available threads.

Computational complexity is $\mathcal{O}(\abs{B}\cdot D)$.

### Non-smooth (non-differentiable) optimization

We’ve defined convexity previously, but we can also use the following alternative characterization of convexity:

$$
\mathcal{L}\left(\pmb u\right) \ge \mathcal{L}\left(\pmb w\right) + \nabla \mathcal{L}\left(\pmb w\right)^T(\pmb{u} - \pmb{w}) \quad \forall \pmb{u}, \pmb{w}
\iff \mathcal{L} \text{ convex}
$$

Meaning that the function must always lie above its linearization (which is the first-order Taylor expansion) to be convex.

![A convex function lies above its linearization](/images/ml/convex-above-linearization.png)

#### Subgradients

A vector $\pmb{g}\in\mathbb{R}^D$ such that:

$$
\mathcal{L}\left(\pmb u\right) \ge \mathcal{L}\left(\pmb w\right) + \pmb{g}^T(\pmb u - \pmb w) \quad \forall \pmb{u}, \pmb{w}
$$

is called a **subgradient** to the function $\mathcal{L}$ at $\pmb w$. The subgradient forms a line that is always below the curve, somewhat like the gradient of a convex function.

![The subgradient lies below the function](/images/ml/subgradient-below-function.png)

This definition is valid even for an arbitrary $\mathcal{L}$ that may not be differentiable, and not even necessarily convex.

If the function $\mathcal{L}$ is differentiable at $\pmb w$, then the *only subgradient* at $\pmb{w}$ is $\pmb{g} = \nabla\mathcal{L}\left(\pmb{w}\right)$.

#### Subgradient descent

This is exactly like gradient descent, except for the fact that we use the *subgradient* $\pmb{g}$ at the current iterate $\pmb{w}^{(t)}$ instead of the *gradient*:

$$
w^{(t+1)} := w^{(t)} - \gamma\pmb{g}
$$

For instance, MAE is not differentiable at 0, so we must use the subgradient.

$$
\text{Let }h: \mathbb{R} \rightarrow \mathbb{R}, \quad h(e) := |e| \\
\text{At } e, \text{the subgradient }
g \in \partial h = \begin{cases}
-1 & \text{if } e < 0 \\
[-1, 1] & \text{if } e = 0 \\
1 & \text{if } e > 0 \\
\end{cases}
$$

Here, $\partial h$ is somewhat confusing notation for the set of all possible subgradients at our position.

For linear regressions, the (sub)gradient is easy to compute using the *chain rule*.

Let $h$ be non-differentiable, $q$ differentiable, and $\mathcal{L}\left(\pmb{w}\right) = h(q(w))$. The chain rule tells us that, at $\pmb w$, our subgradient is:

$$
g \in \partial h(q(\pmb{w})) \cdot \nabla q(\pmb{w})
$$

#### Stochastic subgradient descent

This is still commonly abbreviated SGD.

It’s exactly the same, except that $\pmb g$ is a subgradient to the randomly selected $\mathcal{L}_n$ at the current iterate $\pmb{w}^{(t)}$.



### Comparison

|                             | Smooth                                                       | Non-smooth                                                   |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Full gradient descent       | Gradient of $$\mathcal{L}$$ <br />Complexity is $\mathcal{O}(N\cdot D)$ | Subgradient of $\mathcal{L}$<br />Complexity is $\mathcal{O}(N\cdot D)$ |
| Stochastic gradient descent | Gradient of $\mathcal{L}_n$                                | Subgradient of $\mathcal{L}_n$                             |



### Constrained optimization

Sometimes, optimization problems come posed with an additional constraint.

#### Convex sets

We’ve seen convexity for functions, but we can also define it for sets. A set $\mathcal{C}$ is convex iff the line segment between any two points of $\mathcal{C}$ lies in $\mathcal{C}$. That is, $\forall \pmb{u}, \pmb{v} \in \mathcal{C}, \quad \forall 0 \le \theta \le 1$, we have:

$$
\theta \pmb{u} + (1 - \theta)\pmb{v} \in \mathcal{C}
$$

This means that the line between any two points in the set $\mathcal{C}$ must also be fully contained within the set.

![Examples of convex and non-convex sets](/images/ml/convex-sets.png)

A couple of properties of convex sets:

- Intersection of convex sets is also convex.
- Projections onto convex sets are **unique** (and often efficient to compute).


#### Projected gradient descent

When dealing with constrained problems, we have two options. The first one is to add a projection onto $\mathcal{C}$ in every step:

$$
P_\mathcal{C}(\pmb{w}') := \arg{\min_{\pmb{v}\in\mathcal{C}}}\norm{\pmb{v-w'}}
$$

The rule for gradient descent can thus be updated to become:

$$
w^{(t+1)} := P_\mathcal{C}\left(w^{(t)} - \gamma \nabla \mathcal{L}(w^{(t)}) \right)
$$

This means that at every step, we compute the new $w^{(t+1)}$ normally, but apply a projection on top of that. In other words, if the regular gradient descent sets our weights outside of the constrained space, we project them back.

<figure>
    <img alt="Steps of projected SGD" src="/images/ml/projected-sgd.png" />
    <figcaption>Here, $w'$ is the result of regular SGD, i.e. $w' = w^{(t)} - \gamma \nabla \mathcal{L}(w^{(t)})$</figcaption>
</figure>

This is the same for stochastic gradient descent, and we have the same convergence properties.

Note that the computational cost of the projection is very important here, since it is performed at every step.

#### Turning constrained problems into unconstrained problems

If projection as described above is approach A, this is approach B.

We use a **penalty function**, such as the “brick wall” indicator function below:

$$
I_\mathcal{C}(\pmb w) = \begin{cases}
0 & \pmb{w} \in \mathcal{C} \\
+\infty & \pmb{w} \notin \mathcal{C}
\end{cases}
$$

We could also perhaps use something with a less drastic error value than $+\infty$, if we don’t care about the constraint quite as extreme.

Note that this is similar to regularization, which we’ll talk about later. 

Now, instead of directly solving $min_{\pmb{w}\in\mathcal{C}}{\mathcal{L}(\pmb{w})}$, we solve for:

$$
\min_{\pmb{w}\in \mathbb{R}^D} {
    \mathcal{L}(\pmb{w}) + I_\mathcal{C}(\pmb{w})
}
$$

### Implementation issues in gradient methods

#### Stopping criteria

When $\norm{\mathcal{L}(\pmb{w})}$ is zero (or close to zero), we are often close to the optimum.

#### Optimality

If the second order derivative is positive (or positive semi-definite for the general case $D\ge1$), then it is a (possibly local) minimum. If the function is also convex, then this is necessarily a global minimum. That is:

$$
\nabla \mathcal{L(\pmb{w})} = 0, \quad \mathcal{L} \text{ convex}
\implies
\text{optimum at }\pmb{w}
$$

#### Step size

If $\gamma$ is too big, we might diverge ([as seen previously](#gradient-descent)). But if it is too small, we might be very slow! Convergence is only guaranteed for $\gamma < \gamma_{min}$, which is a value that depends on the problem. 

## Least squares

### Normal equations

In some rare cases, we can take an analytical approach to computing the optimum of the cost function, rather than a computational one; for instance, for linear regressen with MSE, as we've done previously. These types of equations are sometimes called **normal equations**. This is one of the most popular methods for data fitting, called **least squares**.

How do we get these normal equations?

First, we show that the problem is convex. If that is the case, then according to the [optimality conditions](#optimality) for convex functions, the point at which the derivative is zero is the optimum:

$$
\mathcal{L}(\pmb{w}^*)=\pmb{0}
$$

This gives us a system of $D$ equations known as the normal equations.

### Single parameter linear regression
Let's try this for a single parameter linear regression, with MSE as the cost function. 

First, we will just accept that the cost function is convex in the $w_0$ parameter. 

As [proven previously](#gradient-descent), we know that for the single parameter model, the derivative is:

$$
\begin{align}
\nabla\mathcal{L}\left(\pmb{w}\right)
    & = \frac{\partial}{\partial w_0}\mathcal{L} \\
    & = \frac{1}{2N}\sum_{n=1}^N{-2(y_n - w_0)}  \\
    & = w_0 - \bar{y}
\end{align}
$$

This means that the derivative is 0 for $w_0 = \bar{y}$. This allows us to define our optimum parameter $\pmb{w}^\*$ as $\pmb{w}^* = \begin{bmatrix}\bar{y}\end{bmatrix}$.

### Multiple parameter linear regression

As we know by now, the cost function for linear regression with MSE is:

$$
\mathcal{L}\left(\pmb{w}\right)
	:= \frac{1}{2N}\sum_{n=1}^N{\left( y_n - \pmb{x}_n^T \pmb{w}\right)^2}
	=  \frac{1}{2N}(\pmb{y-Xw})^T(\pmb{y-Xw})
$$


Where the matrices are defined as:

$$
\pmb{y}=\begin{bmatrix}
	y_1 \\ y_2 \\ \vdots \\ y_N
\end{bmatrix}, 
\quad
\pmb{X}=\begin{bmatrix}
x_{11} & x_{12} & \dots & x_{1D} \\
x_{21} & x_{22} & \dots & x_{2D} \\
\vdots & \vdots & \ddots & \vdots \\
x_{N1} & x_{N2} & \dots & x_{ND} \\
\end{bmatrix}
$$


We denote the $i^\text{th}$ row of $X$ by $x_i^T$. Each $x_i^T$ represents a different data point.

We claim that this cost function is *convex* in $\pmb{w}$. We can prove that in any of the following ways:

***

#### Simplest way
The cost function is the sum of many convex functions, and is thus also convex.

#### Directly verify the definition

$$
\forall \lambda\in [0,1], 
\quad \forall \pmb{w}, \pmb{w}',
\qquad
\mathcal{L}\left(\lambda\pmb{w} + \left(1-\lambda\right)\pmb{w}'\right) 
- \left(\lambda\mathcal{L}(\pmb{w}) + \left( 1-\lambda \right) \mathcal{L}(\pmb{w}')\right) \le 0
$$
  
The left-hand side of the inequality reduces to:
  
$$
-\frac{1}{2N}\lambda(1-\lambda)\norm{\pmb{X}(\pmb{w}-\pmb{w}')}_2^2
$$
   
which is indeed non-positive.

#### Compute the Hessian

The Hessian is the matrix of second derivatives, defined as follows:

$$
H_{ij} = \left( \frac{\partial\mathcal{L}}{\partial w_i \partial w_j} \right)_{ij}
$$

If the Hessian is positive semidefinite (i.e. all its eigenvalues are non-negative), then the function is convex.
  
For our case, the Hessian is given by:
  
$$
\frac{1}{N}\pmb{X}^T\pmb{X}
$$
  
This is indeed positive semi-definite, as its eigenvalues are the squares of the eigenvalues of $\pmb{X}$, and must therefore be positive.

***

Knowing that the function is convex, we can find the minimum. If we take the gradient of this expression, we get:

$$
\nabla\mathcal{L}(\pmb{w}) = -\frac{1}{N}\pmb{X}^T(\pmb{y-Xw})
$$

We can set this to 0 to get the normal equations for linear regression, which are:

$$
\pmb{X}^T(\pmb{y-Xw}) =: \pmb{X}^T\pmb{e} = \pmb{0}
$$

This proves that the normal equations for linear regression are given by $\pmb{X}^T\pmb{e} = \pmb{0}$.

### Geometric interpretation

The above definition of normal equations are given by $\pmb{X}^T\pmb{e} = \pmb{0}$. How can visualize that?

The error is given by:

$$
\pmb{e} := \pmb{y} - \pmb{Xw}
$$

By definition, this error vector is orthogonal to all columns of $\pmb{X}$. Indeed, it tells us how far above or below the span our prediction $\pmb{y}$ is. 

The **span** of $\pmb{X}$ is the space spanned by the columns of $\pmb{X}$. Every element of the span can be written as $\pmb{u} = \pmb{Xw}$ for some choice of $\pmb{w}$. 

For the normal equations, we must pick an optimal $\pmb{w}^\*$ for which the gradient is 0. Picking an $\pmb{w}^\*$ is equivalent to picking an optimal $\pmb{u}^* = \pmb{Xw}^\*$ from the span of $\pmb{X}$.

But which element of $\text{span}(\pmb{X})$ shall we take, which one is the optimal one? The normal equations tell us that the optimum choice for $\pmb{u}$, called $$\pmb{u}^*$$ is the element such that $$\pmb{y} - \pmb{u}^*$$ is orthogonal to $\text{span}(X)$.

In other words, we should pick $\pmb{u}^*$ to be the projection of $\pmb{y}$ onto $\text{span}(\pmb{X})$.

![Geometric interpretation of the normal equations](/images/ml/geometric-interpretation-normal-equations.png)


### Least squares
All we've done so far is to solve the same old problem of a matrix equation:

$$
Ax = b
$$

But we've always done so with a bit of a twist; there may not be an exact value of $x$ satisfying exact equality, but we could find one that gets us as close as possible:

$$
Ax \approx b
$$

This is also what least squares does. It attempts to minimize the MSE to get as $Ax$ close as possible to $b$.

In this course, we often denote the data matrix $A$ as $\pmb{X}$, the weights $x$ as $\pmb{w}$, and $b$ as $y$; in other words, we're trying to solve:

$$
\pmb{X}\pmb{w} \approx \pmb{y}
$$

In least squares, we multiply this whole equation by $\pmb{X}^T$ on the left. We attempt to find $\pmb{w}^*$, the minimal weight that gets us as minimally wrong as possible. In other we're trying to solve:

$$
\left( \pmb{X}^T\pmb{X} \right) \pmb{w} \approx \pmb{X}^T\pmb{y}
$$

One way to solve this problem would simply be to invert the $A$ matrix, which in our case is $\pmb{X}^T\pmb{X}$:

$$
\pmb{w}^* = (\pmb{X}^T\pmb{X})^{-1} \pmb{X}^T y
$$

As such, we can use this model to predict values for unseen datapoints:

$$
\hat{y}_m := \pmb{x}_m^T \pmb{w}^* = \pmb{x}_m^T (\pmb{X}^T\pmb{X})^{-1} \pmb{X}^T y
$$

### Invertibility and uniqueness
Note that the Gram matrix, defined as $\pmb{X}^T\pmb{X} \in \mathbb{R}^{D\times D}$, is invertible **if and only if** $\pmb{X}$ has **full column rank**, or in other words, $\text{rank}(\pmb{X}) = D$.

$$
\pmb{X}^T\pmb{X} \in \mathbb{R}^{D\times D} \text{ invertible}
\iff
\text{rank}(\pmb{X}) = D
$$

Unfortunately, in practice, our data matrix $\pmb{X}\in\mathbb{R}^{N\times D}$ is often **rank-deficient**.

- If $D>N$, we always have $\text{rank}(\pmb{X}) < D$ (since column and row rank are the same).
- If $D \le N$, but some of the columns $\pmb{x}_{:d}$ are collinear (or in practice, nearly collinear), then the matrix is **ill-conditioned**. This leads to numerical issues when solving the linear system.
  
  To know how bad things are, we can compute the condition number, which is the maximum eigenvalue of the Gram matrix, divided by the minimum See course contents of Numerical Methods.

If our data matrix is rank-deficient or ill-conditioned (which is practically always the case), we certainly shouldn't be inverting it directly! We'll introduce high numerical errors that falsify our output.

That doesn't mean we can't do least squares in practice. We can still use a linear solver. In Python, that means you should use [`np.linalg.solve`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html), which uses a LU decomposition internally and thus avoids the worst numerical errors. In any case, do not directly invert the matrix as we have done above! 


## Maximum likelihood
Maximum likelihood offers a second interpretation of least squares, but starting with a probabilistic approach.

### Gaussian distribution
A Gaussian random variable in $\mathbb{R}$ has mean $\mu$ and variance $\sigma^2$. 

$$
\mathcal{N}(y \mid \mu, \sigma^2) = 
    \frac{1}{\sqrt{2\pi\sigma^2}} 
    \exp{\left[ -\frac{(y-\mu)^2}{2\sigma^2} \right]}
$$

For a Gaussian random *vector* (instead of a single random variable), with mean $\pmb{\mu}$ and covariance $\pmb{\Sigma}$ (which is positive semi-definite) is:

$$
\pmb{\mathcal{N}}(\pmb{y} \mid \pmb{\mu}, \pmb{\Sigma}) = 
    \frac{1}
         {\sqrt{(2\pi)^D \text{ det}(\pmb{\Sigma})}} 

    \exp{\left[ -\frac{1}{2} (\pmb{y} - \pmb{\mu})^T \pmb{\Sigma}^{-1} (\pmb{y} - \pmb{u}) \right]}
$$

Remember that $\pmb{y} \in \mathbb{R}^N$. 

As another reminder, two variables $x$ and $y$ are said to be **independent** when $p(x, y) = p(x)p(y)$.

### A probabilistic model for least squares
We assume that our data is generated by a linear model $\pmb{x}_n^T\pmb{w}$, with added Gaussian noise $\epsilon_n$:

$$
y_n = \pmb{x}_n^T\pmb{w} + \epsilon_n
$$

This is often a realistic assumption in practice.

![Noise generated by a Gaussian source](/images/ml/gaussian-noise.png)

The noise is $\epsilon_n \overset{\text{i.i.d.}}{\sim} \mathcal{N}(y_n \mid \mu = 0, \sigma^2)$ for each dimension $n$. In other words, it is centered at 0, has a certain variance, and the error in each dimension is independent of that in other dimensions. The model $\pmb{w}$ is, as always, unknown.

Given $N$ samples, the **likelihood** of the data vector $\pmb{y} = (y_1, \dots, y_n)$ given the model $\pmb{w}$ and the input $\pmb{X}$ (where each row is one input) is:

$$
p(\pmb{y} \mid \pmb{X}, \pmb{w}) 
    = \prod_{n=1}^N {p(y_n \mid \pmb{x}_n, \pmb{w})}
    = \prod_{n=1}^N {\mathcal{N}(y_n \mid \pmb{x}_n^T\pmb{w}, \sigma^2)}
$$

Intuitively, we'd like to maximize this likelihood over the choice of the best model $\pmb{w}$. The best model is the one that maximizes this likelihood.

### Defining cost with log-likelihood
The log-likelihood (LL) is given by:

$$
\mathcal{L}_{LL} := \log{p(\pmb{y} \mid \pmb{X}, \pmb{w})}
    = - \frac{1}{2\sigma^2} \sum_{n=1}^N{\left(y_n - \pmb{x}_n^T\pmb{w}\right)^2} + \text{ cnst}
$$

Taking the log allows us to get away from the nasty product, and get a nice sum instead.

Notice that this definition looks pretty similar to MSE:

$$
\mathcal{L}_{\text{MSE}}(\pmb{w}) := \frac{1}{N} \sum_{n=1}^N \left(y_n - f(\pmb{x}_n)\right)^2
$$

Note that we would like to minimize MSE, but we want LL to be as high as possible (intuitively, we can look at the sign to understand that).

### Maximum likelihood estimator (MLE)
Maximizing the log-likelihood (and thus the likelihood) will be equivalent to minimizing the MSE; this gives us another way to design cost functions. We can describe the whole process as:

$$
\arg{\min_{\pmb{w}}{\mathcal{L}_\text{MSE}(\pmb{w})}}
=
\arg{\max_{\pmb{w}}{\mathcal{L}_\text{LL}(\pmb{w})}}
$$

The maximum likelihood estimator (MLE) can be understood as finding the model under which the observed data is most likely to have been generated from (probabilistically). This interpretation has some advantages that we discuss below. 

#### Properties of MLE
MLE is a *sample* approximation to the *expected log-likelihood*. In other words, if we had an infinite amount of data, MLE would perfectly be equal to the expected value of the log-likelihood.

$$
\mathcal{L}_{LL}(\pmb{w}) 
    \approx \expectsub{p(y, \pmb{x})}{\log{p(x \mid \pmb{x}, \pmb{w})}}
$$

This means that MLE is **consistent**, i.e. it gives us the correct model assuming we have enough data. In probability, we can write this as:

$$
\pmb{w}_\text{MLE} \longrightarrow^p \pmb{w}_\text{true}
$$

This sounds amazing, but the catch is that this all is under the assumption that the noise $\epsilon$ indeed was generated under a Gaussian model.

## Overfitting and underfitting

### Underfitting with linear models
Linear models can very easily underfit; as soon as the data itself is given by anything more complex than a line, fitting a linear model will underfit: the model is too simple for the data, and we'll have huge errors.

But we can also easily overfit, where our model learns the specificities of the data too intimately. And this happens quite easily with linear combination of high-degree polynomials.

### Extended feature vectors
We can actually get high-degree linear combinations of polynomials, but still keep our linear model. Instead of making the model more complex, we simply "augment" the input to become degree $M$. If the input is one-dimensional, we can add a polynomial basis to the input:

$$
\pmb{\phi}(x_n) =
\begin{bmatrix}
1 & x_n & x_n^2 & x_n^3 & \dots & x_n^M
\end{bmatrix}
$$

Note that this is basically a [Vandermonde matrix](https://en.wikipedia.org/wiki/Vandermonde_matrix).

We then fit a linear model to this extended feature vector $\pmb{\phi}(x_n)$:

$$
y_n \approx w_0 + w_1 x_n + w_2 x_n^2 + \dots + w_m x_n^M =: \pmb{\phi}(x_n)^T\pmb{w}
$$

Here, $\pmb{w}\in\mathbb{R}^{M+1}$. In other words, there are $M+1$ parameters in a degree $M$ extended feature vector. One should be careful with this degree; too high may overfit, too low may underfit.

If it is important to distinguish the original input $\pmb{x}$ from the augmented input $\pmb{\phi}(\pmb{x})$ then we will use the $\pmb{\phi}(\pmb{x})$ notation. But often, we can just consider this as a part of the pre-processing, and simply write $\pmb{x}$ as the input, which will save us a lot of notation.

### Reducing overfitting
To reduce overfitting, we can chose a less complex model (in the above, we can pick a lower degree $M$), but we could also just add more data:

![An overfitted model acts more reasonably when we add a bunch of data](/images/ml/reduce-overfit-add-data.png)

## Regularization
To prevent overfitting, we can introduce **regularization** to penalize complex models. This can be applied to any model.

The idea is to not only minimize cost, but also minimize a regularizer:

$$
\min_{\pmb{w}} {\mathcal{L}(\pmb{w}) + \Omega(\pmb{w})}
$$

The $\Omega$ function is the regularizer, measuring the complexity of the model. We'll see some good candidates for the regularizer below.

### $L_2$-Regularization: Ridge Regression
The most frequently used regularizer is the standard Euclidian norm ($L_2$-norm):

$$
\Omega(\pmb{w}) = \lambda \norm{\pmb{w}}^2_2
$$

Where $\lambda \in \mathbb{R}$. The value of $\lambda$ will affect the fit; $\lambda \rightarrow 0$ can have overfitting, while $\lambda \rightarrow \infty$ can have underfitting.

The norm is given by:

$$
\norm{\pmb{w}}_2^2 = \sum_i{w_i^2}
$$

The main effect of this is that large model weights $w_i$ will be penalized, while small ones won't affect our minimization too much.

#### Ridge regression
Depending on the values we choose for $\mathcal{L}$ and $\Omega$, we get into some special cases. For instance, choosing MSE for $\mathcal{L}$ is called **ridge regression**, in which we optimize the following:

$$
\min_{\pmb{w}} {\left(\frac{1}{N} \sum_{n=1}^N \left[y_n - f(\pmb{x}_n)\right]^2 \quad + \quad \Omega(\pmb{w})\right)}
$$

Least squares is also a special case of ridge regression, where $\lambda = 0$

We can find an explicit solution for $\pmb{w}$ in ridge regression by differentiating the cost and regularizer, and setting them to zero:

$$
\begin{align}
\nabla \mathcal{L}(\pmb{w}) & = -\frac{1}{N} \pmb{X}^T (\pmb{y} - \pmb{Xw}) \\ \\
\nabla \Omega(\pmb{w}) & = 2\lambda \pmb{w} \\
\end{align}
$$

We can now set the full cost to zero, which gives us the result:

$$
\pmb{w}^*_\text{ridge} = (\pmb{X}^T\pmb{X} + \lambda' \pmb{I})^{-1}\pmb{X}^T\pmb{y}
$$

Where $\frac{\lambda'}{2N} = \lambda$. Note that for $\lambda = 0$, we indeed have the solution least squares. 

#### Ridge regression to fight ill-conditioning 
This formulation of $\pmb{w}^*$ is quite nice, because adding the identity matrix helps us get something that always is invertible; in cases where we have ill-conditioned matrices, it also means that we can invert with more stability.

We'll prove that the matrix indeed is invertible. The gist is that the eigenvalues of $(\pmb{X}^T\pmb{X} + \lambda' \pmb{I})$ are all at least $\lambda'$. 

To prove it, we'll write the singular value decomposition (SVD) of $\pmb{X}^T\pmb{X}$ as $\pmb{USU}^T$. We then have:

$$
\pmb{X}^T\pmb{X} + \lambda'\pmb{I} = \pmb{USU}^T + \lambda'\pmb{UIU}^T = \pmb{U}(\pmb{S} + \lambda'\pmb{I})\pmb{U}^T
$$

The singular value is "lifted" by an amount $\lambda'$. There's an alternative proof in the class notes, but we won't go into that.

### $L_1$-Regularization: The Lasso
We can use a different norm as an alternative measure of complexity. The combination of $L_1$-norm and MSE is known as **The Lasso**:

$$
\min_{\pmb{w}} {\frac{1}{2N} \sum_{n=1}^N \left[y_n - f(\pmb{x}_n)\right]^2 \quad + \quad \lambda \norm{w}_1^1}
$$

Where the $L_1$-norm is defined as

$$
\norm{w}_1^1 := \sum_i{\abs{w_i}}
$$

If we draw out a constant value of the $L_1$ norm, we get a sort of "ball". Below, we've graphed $\left\\{ \pmb{w} \mid \norm{\pmb{w}}_1 \le 5 \right\\}$.

![Graph of the lasso](/images/ml/lasso.png)

To keep things in the following, we'll just claim that $\pmb{X}^T\pmb{X}$ is invertible. We'll also claim that the following set is an ellipsoid which scales around the origin as we change $\alpha$:

$$
\left\{
    \pmb{w} \mid \norm{\pmb{y} - \pmb{Xw}}^2 = \alpha
\right\}
$$

The slides have a formal proof for this, but we won't get into it.

Note that the above definition of the set corresponds to the set of points with equal loss (which we can assume is MSE, for instance):

$$
\left\{
    \pmb{w} \mid \mathcal{L}(\pmb{w}) = \alpha
\right\}
$$

Under these assumptions, we claim that for $L_1$ regularization, the optimum solution will likely be sparse (many zero components) compared to $L_2$ regularization.

To prove this, suppose we know the $L_1$ norm of the optimum solution. Visualizing that ball, we know that our optimum solution $\pmb{w}^\*$ will be somewhere on the surface of that ball. We also know that there are ellipsoids, all with the same mean and rotation, describing the equal error surfaces. The optimum solution is where the "smallest" of these ellipsoids just touches the
$L_1$ ball.

![Intersection of the L1 ball and the cost ellipses](/images/ml/ball-ellipse.png)

Due to the geometry of this ball this point is more likely to be on one of the "corner" points. In turn, sparsity is desirable, since it leads to a "simple" model.

## Model selection
As we've seen in ridge regression, we have a *regularization parameter* $\lambda > 0$ that can be tuned to reduce overfitting by reducing model complexity. We say that the parameter $\lambda$  is a **hyperparameter**.

We've also seen ways to enrich model complexity, like [polynomial feature expansion](#extended-feature-vectors), in which the degree $M$ is also a hyperparameter.

We'll now see how best to choose these hyperparamaters; this is called the **model selection** problem.

### Probabilistic setup
We assume that there is an (unknown) underlying distribution $\mathcal{D}$ producing the dataset, with range $\mathcal{X}\times\mathcal{Y}$. The dataset $\mathcal{S}$ we see is produced from samples from $\mathcal{D}$:

$$
S = \left\{(\pmb{x}_n, y_n) 
\overset{\text{i.i.d}}{\sim}
\mathcal{D}\right\}_{n=1}^N
$$

Based on this, the *learning algorithm* choses the "best" model, under the parameters of the algorithm.

We write $f_s = \mathcal{A}(S)$, where $\mathcal{A}$ denotes the learning algorithm. It depends on the data subset we're given, and $f_s$ is the resulting prediction of our model.

To indicate that $f_s$ sometimes depend on hyperparameters, we'll write $f_{s, \lambda}$.

### Training Error vs. Generalization Error
Given a model $f$, how can we asses if $f$ is any good? We already have the loss function, but its result is highly dependent on the error in the data, not to how good the model is. Instead, we can compute the *expected error* over all samples chosen according to $\mathcal{D}$.

$$
L_\mathcal{D}(f) = \expectsub{\mathcal{D}}{\mathcal{l}(y, f(\pmb{x}))}
$$

Where $\mathcal{l}(\cdot, \cdot)$ is our loss function; e.g. for ridge regression, $\mathcal{l}(y, f(\pmb{x})) = \frac{1}{2}(y-f(\pmb{x}))^2$.

The quantity $L_\mathcal{D}(f)$ has many names, including **generalization error** (or true/expected error/risk/loss). This is the quantity that we are fundamentally interested in, but we cannot compute it since $\mathcal{D}$ is unknown.

What we do know is the data subset $\mathcal{S}$. It's therefore natural to compute the equivalent *empirical* quantity, which is the average loss:

$$
L_S(f) = \frac{1}{\abs{S}} \sum_{(\pmb{x}_n, y_n)\in S} {\mathcal{l}(y_n, f(\pmb{x}_n))}
$$

But again, we run into trouble. The function $f$ is itself a function of the data $S$, so what we really do is to compute the quantity:

$$
L_S(f_S) = \frac{1}{\abs{S}} \sum_{(\pmb{x}_n, y_n)\in S} {\mathcal{l}(y_n, f_S(\pmb{x}_n))}
$$

$f_S$ is the trained model. This is called the **training error**. Usually, the training error is smaller than the generalization error, because overfitting can happen (even with regularization, because the hyperparameter may still be too low).

### Splitting the data
To avoid validating the model on the same data subset we trained it on (which is condusive to overfitting), we can split the data into a **training set** and a **test set** (aka *validation set*), which we call $S_\text{train}$ and $S_\text{test}$.

We apply the learning algorithm $\mathcal{A}$ on the training set $S_\text{train}$, and compute the function $f_{S_\text{train}}$. We then compute the error on the test set:

$$
L_{S_\text{test}}(f_{S_\text{train}}) = \frac{1}{\abs{S_\text{test}}} \sum_{(\pmb{x}_n, y_n)\in S_\text{test}} {\mathcal{l}(y_n, f_{S_\text{train}}(\pmb{x}_n))}
$$

If we have duplicates in our data, then this could be a bit dangerous. Still, in general, this really helps us with the problem of overfitting since $S_\text{test}$ is a "fresh" sample, which means that we can hope that $L_{S_\text{test}}(f_{S_\text{train}})$ defined above is close to the quantity $L_\mathcal{D}(f_{S_\text{train}})$. Indeed, *in expectation* both are the same:

$$
L_\mathcal{D}(f_{S_\text{train}}) 
= \expectsub{S_\text{test}\sim\mathcal{D}}{
    L_{S_\text{test}}(f_{S_\text{train}})
}
$$

This is a quite nice property, but there are a few limits. First, we paid a price by splitting the data and thus reducing the size of our training data, though this can be mediated using cross-validation, which we'll see later. 

### Generalization error vs test error
Assume that we have a model $f$ and that our loss function $\mathcal{l}(\cdot, \cdot)$ is bounded in $[a, b]$. We are given a test set $S_\text{test}$ chosen i.i.d. from the underlying distribution $\mathcal{D}$. 

How far apart is the test error (empirical) from the true generalization error? As we've seen above, they are the same in expectation. But we need to worry about the variation, about how far off from the true error we typically are:

We claim that:

$$
\mathbb{P}\left[
    \abs{L_\mathcal{D}(f) - L_{S_\text{test}}(f)}
    \ge
    \sqrt{\frac{(b-a)^2 \ln{(2/\delta)}}{2\abs{S_\text{test}}}}
\right]
\le \delta
\label{eq:loss-bound}
\tag{loss-bound}
$$

Where $\delta > 0$ is a quality parameter. This gives us an upper bound on how far away our empirical loss is from the true loss.

This bound gives us some nice insights. Error decreases in the size of the test set as $\mathcal{O}(1/\sqrt{\abs{S_\text{test}}})$, so the more data points we have, the more confident we can be in the empirical loss being close to the true loss.

We'll prove $\ref{eq:loss-bound}$. We assumed that each sample in the test set is chosen independently. Therefore, given a model $f$, the associated losses $\mathcal{l}(y_n, f(\pmb{x}_n))$ are also i.i.d. random variables, taking values in $[a, b]$ by assumption. We can call each such loss $\Theta_n$:

$$
\Theta_n = \mathcal{l}(y_n, f(\pmb{x}_n))
$$

This is just a naming alias; since the underlying value is that of the loss function, the expected value of $\Theta_n$ is simply that of the loss function, which is the true loss:

$$
\expect{\Theta_n} = \expect{\mathcal{l}(y_n, f(\pmb{x}_n))} = L_\mathcal{D}(f)
$$

The empirical loss on the other hand is equal to the average of $\abs{S_\text{test}}$ such i.i.d. values. 

The formula of $\ref{eq:loss-bound}$ gives us the probability that empirical loss $L_{S_\text{test}}(f)$ diverges from the true loss by more than a given constant, which is a classical problem addressed in the following lemma (which we'll just assert, not prove).

{% comment %} lemma Chernoff Bound {% endcomment %}
**Chernoff Bound**: Let $\Theta_1, \dots, \Theta_n$ be a sequence of i.i.d random variables with mean $\expect{\Theta}$ and range $[a, b]$. Then, for any $\epsilon > 0$:

$$
\mathbb{P}\left[
    \abs{\frac{1}{N}\sum_{n=1}^N {\Theta_n - \expect{\Theta}}}
    \ge
    \epsilon
\right]
\le
2\exp{\left(\frac{-2N\epsilon^2}{(b-a)^2}\right)}
\label{eq:Chernoff}
\tag{Chernoff}
$$
{% comment %} endlemma {% endcomment %}

Using $\ref{eq:Chernoff}$ we can show $\ref{eq:loss-bound}$. By setting $\delta = 2\exp{\left(\frac{-2N\epsilon^2}{(b-a)^2}\right)}$, we find that $\epsilon = \sqrt{\frac{(b-a)^2 \ln{(2/\delta)}}{2\abs{S_\text{test}}}}$ as claimed.

### Model selection
Our main goal was to look for a way to select the hyperparameters of our model. Given a finite set of values $\lambda_k$ for $k=1, \dots, K$ of a hyperparameter $\lambda$, we can run the learning algorithm $K$ times on the same training set $S_\text{train}$, and compute the $K$ prediction functions $f_{S_\text{train}, \lambda_k}$. For each such prediction function we compute the test error, and choose the $\lambda_k$ which minimizes the test error.

This is essentially a grid search on $\lambda$ using the test error function.

#### Model selection based on test error
How do we know that, for a fixed function $f$, $L_{S_\text{test}}(f)$ is a good approximation to $f_\mathcal{D}$?

The answer to this follows the same idea as when we talked about [generalization vs test error](#generalization-error-vs-test-error), but we now assume that we have $K$ models $f_k$ for $k=1, \dots, K$. We assume again that the loss function is bounded in $[a, b]$, and that we're given a test set whose samples are chosen iid in $\mathcal{D}$.

How far is each of the $K$ (empirical) test errors $L_{S_\text{test}}(f_k)$ from the true $L_\mathcal{D}(f_k)$? As before, we can bound the deviation for all $k$ candidates, by:

$$
\mathbb{P}\left[
    \max_k {\abs{L_\mathcal{D}(f_k) - L_{S_\text{test}}(f_k)}}
    \ge
    \sqrt{\frac{(b-a)^2 \ln{(2K/\delta)}}{2\abs{S_\text{test}}}}
\right]
\le \delta
$$

A bit of intuition of where this comes from: for a general $K$, if we check the deviations for $K$ independent samples and ask for the probability that for at least one such sample we get a deviation of at least $\epsilon$ (this is what the Chernoff bound answers). Then by the union bound this probability is at most $K$ times as large as in the case where we are only concerned with a single instance. Thus the upper bound in Chernoff becomes $2K\exp{\left(\frac{-2N\epsilon^2}{(b-a)^2}\right)}$, which gives us $\epsilon = \sqrt{\frac{(b-a)^2 \ln{(2K/\delta)}}{2\abs{S_\text{test}}}}$ as above.

As before, this tells us that error decreases in $\mathcal{O}(1/\sqrt{\abs{S_\text{test}}})$. Now that we test $K$ hyperparameters, our error only goes up by a tiny amount of $\sqrt{\ln{(K)}}$. This follows from $\ref{eq:loss-bound}$, which we proved for the special case of $K = 1$.

### Cross-validation
Splitting the data once into two parts (one for training and one for testing) is not the most efficient way to use the data. Cross-validation is a better way.

K-fold cross-validation is a popular variant. We randomly partition the data into $K$ groups, and train $K$ times. Each time, we use one of the $K$ groups as our test set, and the remaining $K−1$ groups for training. 

To get a common result, we average out the $K$ results. This means we'll use  the average weights to get the average test error over the $K$ folds.

Cross-validation returns an unbiased estimate of the generalization error and its variance.

### Bias-Variance decomposition
When we perform model selection, there is an inherent [bias&ndash;variance](https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff) trade-off.

{% comment %} Todo copy bias variance image {% endcomment %}

For now, we'll just look at "high-bias & low-variance" models, and "high-variance & low-bias" models.

- **High-bias & low-variance**: the model is too simple. It's underfit, has a large bias, and and the variance of $L_\mathcal{D}(f_S)$ is small.
- **High-variance & low-bias**: the model is too complex. It's overfit, has a small bias and large variance of $L_\mathcal{D}(f_S)$ (as a single addition of a data point is likely to change the prediction function $f_S$ considerably)

Consider a linear regression with one-dimensional input and [polynomial feature expansion](#extended-feature-vectors) of degree $d$. The former can be achieved by picking a too low value for $d$, while the latter by picking $d$ too high. The same principle applies for other parameters, such as ridge regression with hyperparameter $\lambda$.

#### Data generation model
Let's assume that our data is generated by some arbitrary, unknown function $f$, and a noise source with distribution $\mathcal{D}_\epsilon$ (i.i.d. from sample to sample, and independent from the data). We can think of $f$ representing the precise, hypothetical function that perfectly produced the data. We assume that the noise has mean zero (without loss of generality, as a non-zero mean could be encoded into $f$).

$$
y = f(\pmb{x}) + \epsilon
$$

We assume that $\pmb{x}$ is generated according to some fixed but unknown distribution $\mathcal{D}_{\pmb{x}}$. We'll be working with square loss as our loss function $\mathcal{l}(\cdot, \cdot)$. We will denote the joint distribution on pairs $(\pmb{x}, y)$ as $\mathcal{D}$.

#### Error Decomposition
As always, we have a training set $S_\text{train}$, which consists of $N$ i.i.d. samples from $\mathcal{D}$. Given our learning algorithm $\mathcal{A}$, we compute the prediction function $f_{S_\text{train}} = \mathcal{A}(S_\text{train})$. The square loss of a single prediction for a fixed element $\pmb{x}_0$ is given by the computation of:

$$
\bigl( y_0 - f_{S_\text{train}}(\pmb{x}_0) \bigr)^2
= 
\bigl( f(\pmb{x}_0) + \epsilon - f_{S_\text{train}}(\pmb{x}_0) \bigr)^2
$$

Our experiment was to create $S_\text{train}$, learn $f_{S_\text{train}}$, and then evaluate the performance by computing the square loss for a fixed element $\pmb{x}_0$. If we run this experimant many times, the expected value is written as:

$$
\expectsub{S_\text{train} \sim \mathcal{D},\ \epsilon\sim\mathcal{D}_\epsilon}{
    \left( f(\pmb{x}_0) + \epsilon - f_{S_\text{train}}(\pmb{x}_0) \right)^2
}
$$

We will now show that this expression can be rewritten as a sum of three non-negative terms, and that each of these:

$$
\newcommand{\otherconstantterm}{\mathbb{E}_{S'_\text{train}\sim\mathcal{D}}\left[f_{S'_\text{train}}(\pmb{x}_0)\right]}

\begin{align}
& \expectsub{S_\text{train} \sim \mathcal{D},\ \epsilon\sim\mathcal{D}_\epsilon} {
    \left( f(\pmb{x}_0) + \epsilon - f_{S_\text{train}}(\pmb{x}_0) \right)^2
} \\

\overset{(a)}{=}\  & 
    \expectsub{\epsilon\sim\mathcal{D}_\epsilon} {
        \epsilon^2
    }
    + \expectsub{S_\text{train} \sim \mathcal{D}} {
        \bigl(f(\pmb{x}_0) - f_{S_\text{train}}(\pmb{x}_0)\bigl)^2
    } \\

\overset{(b)}{=}\ & 
    \text{Var}_{\epsilon\sim\mathcal{D}_\epsilon}\left[\epsilon\right]
    + \expectsub{S_\text{train} \sim \mathcal{D}}{
        \bigl(f(\pmb{x}_0) - f_{S_\text{train}}(\pmb{x}_0)\bigl)^2
    } \\

\overset{(c)}{=}\ &
    \underbrace{
        \text{Var}_{\epsilon\sim\mathcal{D}_\epsilon}\left[\epsilon\right]
    }_\text{noise variance} \\
& + \underbrace{
    \left( f(\pmb{x}_0) - \otherconstantterm \right)^2
}_\text{bias} \\
& + \expectsub{S_\text{train}\sim\mathcal{D}} {
        \underbrace{
            \left( \otherconstantterm - f_{S_\text{train}(\pmb{x}_0)} \right)^2
        }_\text{variance}
    } \\
\end{align}
$$

Note that here, $S\'\_\text{train}$ is a second training set, also sampled from $\mathcal{D}$, that is independent of the training set $S_\text{train}$. It has the same expectation, but it is different and thus produces a different trained model $f_{S'}$.

Step $(a)$ uses $(u+v)^2 = u^2 + 2uv + v^2$ as well as linearity of expectation produce $\expect{(u+v)^2} = \expect{u^2} + 2\expect{uv} + \expect{v^2}$. Note that the $2uv$ part is zero as the noise $\epsilon$ is independent from $S_\text{train}$.

Step $(b)$ uses the definition of variance as:

$$
\text{Var}(X) = \expect{(X - \expect{X})^2} = \expect{X^2} - \expect{X}^2
$$

Seeing that our noise $\epsilon$ has mean zero, we have $\expect{\epsilon}^2 = 0$ and therefore $\text{Var}(\epsilon) = \expect{\epsilon^2}$. 

In step $(c)$, we add and substract the constant term $\otherconstantterm$ to the expression like so:

$$
\expectsub{S\sim \mathcal{D}}{\left(
    \underbrace{A - \otherconstantterm}_u + \underbrace{\otherconstantterm + B}_v
\right)^2}
$$

We can then expand the square. The $2uv$ part of the expansion is zero, as we show below:

$$
\begin{align}
& \expectsub{S \sim \mathcal{D}} {
    \left( 
        f(\pmb{x}_0) - \otherconstantterm 
    \right) \cdot \left(
        \otherconstantterm - f_S(\pmb{x}_0)
    \right)
} \\
& = \left(
    f(\pmb{x}_0) - \otherconstantterm 
\right) \cdot \expectsub{S\sim\mathcal{D}} {
    \otherconstantterm - f_S(\pmb{x}_0)
} \\
& = \left(
    f(\pmb{x}_0) - \otherconstantterm 
\right) \cdot \left(
    \otherconstantterm - \expectsub{S\sim\mathcal{D}}{S(\pmb{x}_0)}
\right) \\
& = 0 \\
\end{align} 
$$

#### Interpretation of the decomposition
Each of the three terms in non-negative, so each of them is a lower bound on the expected loss when we predict the value for the input $\pmb{x}_0$.

- When the data contains **noise**, then that imposes a strict lower bound on the error we can achieve.
- The **bias term** is a non-negative term that tells us how far we are from the true value, in expectation. It's the square loss between the actual value $f(\pmb{x}_0)$ and the expected prediction, where the expectation is over the training sets. As [we discussed above](#bias-variance-decomposition), with a simple moedl we will not find a good fit in average, which means the bias will be large, which adds to the error we observe.
- The **variance term** is the variance of the prediction function. For complex models, small variations in the data set can produce vastly different models, and our prediction will vary widely, which also adds to our total error.

