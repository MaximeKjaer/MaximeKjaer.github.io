---
title: CS-452 Foundations of Software
description: "My notes from the CS-452 Foundations of Software course given at EPFL, in the 2018 autumn semester (MA1)"
unlisted: true
edited: true
---

* TOC
{:toc}

## Writing a parser with parser combinators
In Scala, you can (ab)use the operator overload to create an embedded DSL (EDSL) for grammars. While a grammar may look as follows in a grammar description language (Bison, Yak, ANTLR, ...):

{% highlight antlr linenos %}
Expr ::= Term {'+' Term | 'âˆ’' Term}
Term ::= Factor {'âˆ—' Factor | '/' Factor}
Factor ::= Number | '(' Expr ')'
{% endhighlight %}

In Scala, we can model it as follows:

{% highlight scala linenos %}
def expr: Parser[Any] = term ~ rep("+" ~ term | "âˆ’" ~ term)
def term: Parser[Any] = factor ~ rep("âˆ—" ~ factor | "/" ~ factor)
def factor: Parser[Any] = "(" ~ expr ~ ")" | numericLit
{% endhighlight %}

This is perhaps a little less elegant, but allows us to encode it directly into our language, which is often useful for interop.

The `~`, `|`, `rep` and `opt` are **parser combinators**. These are primitives with which we can construct a full parser for the grammar of our choice.

### Boilerplate

First, let's define a class `ParseResult[T]` as an ad-hoc monad; parsing can either succeed or fail:

{% highlight scala linenos %}
sealed trait ParseResult[T]
case class Success[T](result: T, in: Input) extends ParseResult[T]
case class Failure(msg : String, in: Input) extends ParseResult[Nothing]
{% endhighlight %}

> ðŸ‘‰ `Nothing` is the bottom type in Scala; it contains no members, and nothing can extend it

Let's also define the tokens produced by the lexer (which we won't define) as case classes extending `Token`:

{% highlight scala linenos %}
sealed trait Token
case class Keyword(chars: String) extends Token
case class NumericLit(chars: String) extends Token
case class StringLit(chars: String) extends Token
case class Identifier(chars: String) extends Token
{% endhighlight %}

Input into the parser is then a lazy stream of tokens (with positions for error diagnostics, which we'll omit here):

{% highlight scala linenos %}
type Input = Reader[Token]
{% endhighlight %}

We can then define a standard, sample parser which looks as follows on the type-level:

{% highlight scala linenos %}
class StandardTokenParsers {
    type Parser = Input => ParseResult
}
{% endhighlight %}

### The basic idea
For each language (defined by a grammar symbol `S`), define a function `f` that, given an input stream `i` (with tail `i'`):

- if a prefix of `i` is in `S`, return `Success(Pair(x, i'))`, where `x` is a result for `S`
- otherwise, return `Failure(msg, i)`, where `msg` is an error message string

The first is called *success*, the second is *failure*. We can compose operations on this somewhat conveniently, like we would on a monad (like `Option`).

### Simple parser primitives
All of the above boilerplate allows us to define a parser, which succeeds if the first token in the input satisfies some given predicate `pred`. When it succeeds, it reads the token string, and splits the input there.

{% highlight scala linenos %}
def token(kind: String)(pred: Token => boolean) = new Parser[String] {
    def apply(in : Input) =
        if (pred(in.head)) Success(in.head.chars, in.tail)
        else Failure(kind + " expected ", in)
}
{% endhighlight %}

We can use this to define a keyword parser:

{% highlight scala linenos %}
implicit def keyword(chars: String) = token("'" + chars + "'") {
    case Keyword(chars1) => chars == chars1
    case _ => false
}
{% endhighlight %}

Marking it as `implicit` allows us to write keywords as normal strings, where we can omit the `keyword` call (this helps us simplify the notation in our DSL; we can write `"if"` instead of `keyword("if")`).

We can make other parsers for our other case classes quite simply:

{% highlight scala linenos %}
def numericLit = token("number")( .isInstanceOf[NumericLit])
def stringLit = token("string literal")( .isInstanceOf[StringLit])
def ident = token("identifier")( .isInstanceOf[Identifier])
{% endhighlight %}

### Parser combinators
We are going to define the following parser combinators:

- `~`: sequential composition
- `<~`, `>~`: sequential composition, keeping left / right only
- `|`: alternative
- `opt(X)`: option (like a `?` quantifier in a regex)
- `rep(X)`: repetition (like a `*` quantifier in a regex)
- `repsep(P, Q)`: interleaved repetition
- `^^`: result conversion (like a `map` on an `Option`)
- `^^^`: constant result (like a `map` on an `Option`, but returning a constant value regardless of result)

But first, we'll write some very basic parser combinators: `success` and `failure`, that respectively always succeed and always fail:

{% highlight scala linenos %}
def success[T](result: T) = new Parser[T] {
    def apply(in: Input) = Success(result, in)
}

def failure(msg: String) = new Parser[Nothing] {
    def apply(in: Input) = Failure(msg, in)
}
{% endhighlight %}

All of the above are methods on a `Parser[T]` class. Thanks to infix space notation in Scala, we can denote `x.y(z)` as `x y z`, which allows us to simplify our DSL notation; for instance `A ~ B` corresponds to `A.~(B)`.

{% highlight scala linenos %}
abstract class Parser[T] {
    // An abstract method that defines the parser function
    def apply(in : Input): ParseResult

    def ~[U](rhs: Parser[U]) = new Parser[T ~ U] {
        def apply(in: Input) = Parser.this(in) match {
            case Success(x, tail) => rhs(tail) match {
                case Success(y, rest) => Success(new ~(x, y), rest)
                case failure => failure
            }
            case failure => failure
        }
    }

    def |(rhs: => Parser[T]) = new Parser[T] {
        def apply(in : Input) = Parser.this(in) match {
            case s1 @ Success(_, _) => s1
            case failure => rhs(in)
        }
    }

    def ^^[U](f: T => U) = new Parser[U] {
        def apply(in : Input) = Parser.this(in) match {
            case Success(x, tail) => Success(f(x), tail)
            case x => x
        }
    }

    def ^^^[U](r: U): Parser[U] = ^^(x => r)
}
{% endhighlight %}

> ðŸ‘‰ In Scala, `T ~ U` is syntactic sugar for `~[T, U]`, which is the type of the case class we'll define below

For the `~` combinator, when everything works, we're using `~`, a case class that is equivalent to `Pair`, but prints the way we want to and allows for the concise type-level notation above.

{% highlight scala linenos %}
case class ~[T, U](_1 : T, _2 : U) {
    override def toString = "(" + _1 + " ~ " + _2 +")"
}
{% endhighlight %}

At this point, we thus have **two** different meanings for `~`: a *function* `~` that produces a `Parser`, and the `~(a, b)` *case class* pair that this parser returns (all of this is encoded in the function signature of the `~` function).

Note that the `|` combinator takes the right-hand side parser as a call-by-name argument. This is because we don't want to evaluate it unless it is strictly neededâ€”that is, if the left-hand side fails.

`^^` is like a `map` operation on `Option`; `P ^^ f` succeeds iff `P` succeeds, in which case it applies the transformation `f` on the result of P. Otherwise, it fails.

### Shorthands

We can now define shorthands for common combinations of parser combinators:

{% highlight scala linenos %}
def opt[T](p : Parser[T]): Parser[Option[T]] = p ^^ Some | success(None)

def rep[T](p : Parser[T]): Parser[List[T]] = 
    p ~ rep(p) ^^ { case x ~ xs => x :: xs } | success(Nil)

def repsep[T, U](p : Parser[T], q : Parser[U]): Parser[List[T]] = 
    p ~ rep(q ~> p) ^^ { case r ~ rs => r :: rs } | success(Nil)
{% endhighlight %}

Note that none of the above can fail. They may, however, return `None` or `Nil` wrapped in `success`.


As an exercise, we can implement the `rep1(P)` parser combinator, which corresponds to the `+` regex quantifier:

{% highlight scala linenos %}
def rep1[T](p: Parser[T]) = p ~ rep(p)
{% endhighlight %}

### Example: JSON parser

We did not mention `lexical.delimiters` and `lexical.reserved` in the above, and for the sake of brevity, we omit the implementation of `stringLit` and `numericLit`.

{% highlight scala linenos %}
object JSON extends StandardTokenParsers {
    lexical.delimiters += ("{", "}", "[", "]", ":")
    lexical.reserved += ("null", "true", "false")

    // Return Map
    def obj: Parser[Any] = "{" ~ repsep(member, ",") ~ "}" ^^ (ms => Map() ++ ms)

    // Return List
    def arr: Parser[Any] = "[" ~> repsep(value, ",") <~ "]"

    // Return name/value pair:
    def member: Parser[Any] = stringLit ~ ":" ~ value ^^ {
        case name ~ ":" ~ value => (name, value) 
    }

    // Return correct Scala type
    def value: Parser[Any] =
          obj 
        | arr 
        | stringLit
        | numericLit ^^ (_.toInt)
        | "null" ^^^ null
        | "true" ^^^ true
        | "false" ^^^ false
}
{% endhighlight %}

### The trouble with left-recursion

Parser combinators work top-down and therefore do not allow for left-recursion. For example, the following would go into an infinite loop, where the parser keeps recursively matching the same token unto `expr`:

{% highlight scala linenos %}
def expr = expr ~ "-" ~ term
{% endhighlight %}

Let's take a look at an arithmetic expression parser:

{% highlight scala linenos %}
object Arithmetic extends StandardTokenParsers {
    lexical.delimiters ++= List("(", ")", "+", "âˆ’", "âˆ—", "/")
    def expr: Parser[Any] = term ~ rep("+" ~ term | "âˆ’" ~ term)
    def term: Parser[Any] = factor ~ rep("âˆ—" ~ factor | "/" ~ factor)
    def factor: Parser[Any] = "(" ~ expr ~ ")" | numericLit
}
{% endhighlight %}

This definition of `expr`, namely `term ~ rep("-" ~ term)` produces a right-leaning tree. For instance, `1 - 2 - 3` produces `1 ~ List("-" ~ 2, ~ "-" ~ 3)`. 

The solution is to combine calls to `rep` with a final foldLeft on the list:

{% highlight scala linenos %}
object Arithmetic extends StandardTokenParsers {
    lexical.delimiters ++= List("(", ")", "+", "âˆ’", "âˆ—", "/")
    def expr: Parser[Any] = term ~ rep("+" ~ term | "âˆ’" ~ term) ^^ reduceList
    def term: Parser[Any] = factor ~ rep("âˆ—" ~ factor | "/" ~ factor) ^^ reduceList
    def factor: Parser[Any] = "(" ~ expr ~ ")" | numericLit

    private def reduceList(list: Expr ~ List[String ~ Expr]): Expr = list match {
        case x ~ xs => (x foldLeft ps)(reduce)
    }

    private def reduce(x: Int, r: String ~ Int) = r match {
        case "+" ~ y => x + y
        case "âˆ’" ~ y => x âˆ’ y
        case "âˆ—" ~ y => x âˆ— y
        case "/" ~ y => x / y
        case => throw new MatchError("illegal case: " + r)
    }
}
{% endhighlight %}

> ðŸ‘‰ It used to be that the standard library contained parser combinators, but those are now a [separate module](https://github.com/scala/scala-parser-combinators). This module contains a `chainl` (chain-left) method that reduces after a `rep` for you.

## Arithmetic expressions â€” abstract syntax and proof principles
This section follows Chapter 3 in TAPL.

### Basics of induction
Ordinary induction is simply:

```
Suppose P is a predicate on natural numbers.
Then:
	If P(0)
	and, for all i, P(i) implies P(n) holds for all n
	then P(n) holds for all n
```

We can also do complete induction:

```
Suppose P is a predicate on natural numbers.
Then:
	If for each natural number n,
	given P(i) for all i < n we can show P(n)
	then P(n) holds for all n
```

It proves exactly the same thing as ordinary induction, it is simply a restated version. They're *interderivable*; assuming one, we can prove the other. Which one to use is simply a matter of style or convenience. We'll see some more equivalent styles as we go along.

### Mathematical representation
Let's assume the following grammar:

{% highlight antlr linenos %}
t ::= 
    true
    false
    if t then t else t
    0
    succ t
    pred t
    iszero t
{% endhighlight %}

What does this really define? A few suggestions:

- A set of character strings
- A set of token lists
- A set of abstract syntax trees

It depends on how you read it; a grammar like the one above contains information about all three.

However, we are mostly interested in the ASTs. The above grammar is therefore called an **abstract grammar**. Its main purpose is to suggest a mapping from character strings to trees.

For our use of these, we won't be too strict with these. For instance, we'll freely use parentheses to disambiguate what tree we mean to describe, even though they're not strictly supported by the grammar. What matters to us here aren't strict implementation semantics, but rather that we have a framework to talk about ASTs. For our purposes, we'll consider that two terms producing the same AST are basically the same; still, we'll distinguish terms that only have the same evaluation result, as they don't necessarily have the same AST.

How can we express our grammar as mathematical expressions? A grammar describes the legal *set* of terms in a program by offering a recursive definition. While recursive definitions may seem obvious and simple to a programmer, we have to go through a few hoops to make sense of them mathematically.

#### Mathematical representation 1
We can use a set $\mathcal{T}$ of terms; it is the smallest set such that:

1. $\left\\{ \text{true}, \text{false}, 0 \right\\} \subseteq \mathcal{T}$,
2. If $t_1 \in \mathcal{T}$ then $\left\\{ \text{succ } t_1, \text{pred } t_1, \text{iszero } t_1 \right\\} \subseteq \mathcal{T}$,
3. If $t_1, t_2, t_3 \in \mathcal{T}$ then we also have $\text{if } t_1 \text{ then } t_2 \text{ else } t_3 \in \mathcal{T}$.

#### Mathematical representation 2
We can also write this somewhat more graphically:

$$
\text{true } \in \mathcal{T},  \quad
\text{false } \in \mathcal{T}, \quad
0 \in \mathcal{T}              \\ \\

\frac{t_1 \in \mathcal{T}}{\text{succ } t_1 \in \mathcal{T}}, \quad
\frac{t_1 \in \mathcal{T}}{\text{pred } t_1 \in \mathcal{T}}, \quad
\frac{t_1 \in \mathcal{T}}{\text{iszero } t_1 \in \mathcal{T}} \\ \\

\frac{t_1 \in \mathcal{T}, \quad t_2 \in \mathcal{T}, \quad t_3 \in \mathcal{T}}{\text{if } t_1 \text{ then } t_2 \text{ else } t_3 \in \mathcal{T}}
$$

This is exactly equivalent to representation 1, but we have just introduced a different notation. Note that "the smallest set closed under..." is often not stated explicitly, but implied.

#### Mathematical representation 3
Alternatively, we can build up our set of terms as an infinite union:

$$
\begin{align}
\mathcal{S}_0 = & & \emptyset \\
\mathcal{S}_{i+1} = 
    &      & \left\{ \text{true}, \text{ false}, 0 \right\} \\
    & \cup & \left\{ \text{succ } t_1, \text{pred } t_1, \text{iszero } t_1 | t_1 \in \mathcal{S}_i \right\} \\
    & \cup & \left\{ \text{if } t_1 \text{ then } t_2 \text{ else } t_3 | t_1, t_2, t_3 \in \mathcal{S}_i \right\}
\end{align}
$$

We can thus build our final set as follows:

$$
\mathcal{S} = \bigcup_i{\mathcal{S}_i}
$$

Note that we can "pull out" the definition into a generating function $F$:

$$
\begin{align}
\mathcal{S}_0     & = \emptyset \\
\mathcal{S}_{i+1} & = F(\mathcal{S}_i) \\
\mathcal{S}       & = \bigcup_i{\mathcal{S}_i} \\
\end{align}
$$

The generating function is thus defined as:

$$
\begin{align}
F_1(U) & = \left\{ \text{true} \right\} \\
F_2(U) & = \left\{ \text{false} \right\} \\
F_3(U) & = \left\{ 0 \right\} \\
F_4(U) & = \left\{ \text{succ } t_1 | t_1 \in U \right\} \\
F_5(U) & = \left\{ \text{pred } t_1 | t_1 \in U \right\} \\
F_6(U) & = \left\{ \text{iszero } t_1 | t_1 \in U \right\} \\
F_7(U) & = \left\{ \text{if } t_1 \text{ then } t_2 \text{ else } t_3 | t_1, t_2, t_3 \in U \right\} \\
\end{align} \\

F(U) = \bigcup_{i=1}^7{F_i(U)}
$$

Each function takes a set of terms $U$ as input and produces "terms justified by $U$" as output; that is, all terms that have the items of $U$ as subterms.

The set $U$ is said to be **closed under F** or **F-closed** if $F(U) \subseteq U$.

The set of terms $\mathcal{T}$ as defined above is the smallest F-closed set. If $\mathcal{O}$ is another F-closed set, then $\mathcal{T} \subseteq \mathcal{O}$.

#### Comparison of the representations
We've seen essentially two ways of defining the set (as representation 1 and 2 are equivalent, but with different notation):

1. The smallest set that is closed under certain rules. This is compact and easy to read.
2. The limit of a series of sets. This gives us an *induction principle* on which we can prove things on terms by induction. 

The first one defines the set "from above", by intersecting F-closed sets.

The second one defines it "from below", by starting with $\emptyset$ and getting closer and closer to being F-closed.

These are equivalent (we won't prove it, but Proposition 3.2.6 in TAPL does so), but can serve different uses in practice.

### Induction on terms
First, let's define depth: 

The **depth** of a term $t$ is the smallest $i$ such that $t\in\mathcal{S_i}$.

The way we defined $\mathcal{S}_i$, it gets larger and larger for increasing $i$; the depth gives us the step at which it is introduced into the set.

We see that if a term $t$ is in $$\mathcal{S}_i$$, then all of its immediate subterms must be in $\mathcal{S}_{i-1}$, meaning that they must have smaller depth.

This justifies the principle of **induction on terms**. Let P be a predicate on a term:

```
If, for each term s,
    given P(r) for all immediate subterms r of s we can show P(s)
    then P(t) holds for all t
```

All this says is that if we can prove the induction step from subterms to terms (under the induction hypothesis), then we have proven the induction.

### Inductive function definitions
An [inductive definition](https://en.wikipedia.org/wiki/Recursive_definition) is used to define the elements in a set recursively, as we have done above. The [recursion theorem](https://en.wikipedia.org/wiki/Recursion#The_recursion_theorem) states that a well-formed inductive definition indeed defines a function, but we'll get into that later.

Let's define our grammar function a little more formally. Constants are the basic values that can't be expanded further; in our example, they are `true`, `false`, `0`. As such, the set of constants appearing in a term $t$, written $\text{Consts}(t)$, is defined as follows:

$$
\begin{align}
\text{Consts}(\text{true})  & = \left\{ \text{true}  \right\} \\
\text{Consts}(\text{false}) & = \left\{ \text{false} \right\} \\
\text{Consts}(0)            & = \left\{ 0            \right\} \\

\text{Consts}(\text{succ } t_1) & = \text{Consts}(t_1) \\
\text{Consts}(\text{pred } t_1) & = \text{Consts}(t_1) \\
\text{Consts}(\text{iszero } t_1) & = \text{Consts}(t_1) \\
\text{Consts}(\text{if } t_1 \text{ then } t_2 \text{ else } t_3) & = \text{Consts}(t_1) \cup \text{Consts}(t_2) \cup \text{Consts}(t_3) \\
\end{align}
$$

This seems simple, but these semantics aren't perfect. First off, a mathematical definition simply assigns a convenient name to some previously known thing. But here, we're defining the thing in terms of itself, recursively. And the semantics above also allow us to define ill-formed inductive definitions:

$$
\begin{align}
\text{BadConsts}(\text{true})  & = \left\{ \text{true}  \right\} \\
\text{BadConsts}(\text{false}) & = \left\{ \text{false} \right\} \\
\text{BadConsts}(0)            & = \left\{ 0            \right\} \\
\text{BadConsts}(0)            & = \left\{ \right\} = \emptyset  \\

\text{BadConsts}(\text{succ } t_1) & = \text{BadConsts}(t_1) \\
\text{BadConsts}(\text{pred } t_1) & = \text{BadConsts}(t_1) \\
\text{BadConsts}(\text{iszero } t_1) & = \text{BadConsts}(\text{iszero iszero }t_1) \\
\end{align}
$$

The last rule produces infinitely large rules (if we implemented it, we'd expect some kind of stack overflow). We're missing the rules for if-statements, and we have a useless rule for `0`, producing empty sets.

How do we tell the difference between a well-formed inductive definition, and an ill-formed one as above? What is well-formedness anyway? 

#### What is a function?

A relation over $T, U$ is a subset of $T \times U$, where the Cartesian product is defined as:

$$
T\times U = \left\{ (t, u) : t\in T, u\in U \right\}
$$

A function $f$ from $A$ (domain) to $B$ (co-domain) can be viewed as a two-place relation, albeit with two additional properties:

- It is **total**: $\forall a \in A, \exists b \in B : (a, b) \in f$
- It is **deterministic**: $(a, b_1) \in f, (a, b_2) \in f \implies b_1 = b_2$

Totality ensures that the A domain is covered, while being deterministic just means that the function always produces the same result for a given input.

#### Induction theorem 
As previously stated, $\text{Consts}$ is a *relation*. It maps terms (A) into the set of constants that they contain (B). The induction theorem states that it is also a *function*. The proof is as follows.

$\text{Consts}$ is total and deterministic: for each term $t$ there is exactly one set of terms $C$ such that $(t, C) \in \text{Consts}$. Not that this inclusion notation is equivalent to saying $\text{Consts}(t) = C$. The proof is done by induction on $t$.

To be able to apply the induction principle for terms, we must first show that for an arbitrary term $t$, under the following induction hypothesis:

> For each immediate subterm $s$ of $t$, there is exactly one set of terms $C_s$ such that $(s, C_s) \in \text{Consts}$

Then the following needs to be proven as an induction step:

> There is **exactly one** set of terms $C$ such that $(t, C) \in \text{Consts}$

We proceed by cases on $t$ (as if we were pattern matching ðŸ˜‰):

- If $t$ is $0$, $\text{true}$ or $\text{false}$
  
  We can immediately see from the definition that of $\text{Consts}$ that there is exactly one set of terms $C = \left\\{ t \right\\}$) such that $(t, C) \in \text{Consts}$.

  This constitutes our base case.
  
- If $t$ is $\text{succ } t_1$, $\text{pred } t_1$ or $\text{iszero } t_1$
  
  The immediate subterm of $t$ is $t_1$, and the induction hypothesis tells us that there is exactly one set of terms $C_1$ such that $(t_1, C_1) \in \text{Consts}$. But then it is clear from the definition that there is exactly one set of terms $C = C_1$ such that $(t, C) \in \text{Consts}$.
  
- If $t$ is $\text{if } t_1 \text{ then } t_2 \text{ else } t_3$
  
  The induction hypothesis tells us:

    - There is exactly one set of terms $C_1$ such that $(t_1, C_1) \in \text{Consts}$
    - There is exactly one set of terms $C_2$ such that $(t_2, C_2) \in \text{Consts}$
    - There is exactly one set of terms $C_3$ such that $(t_3, C_3) \in \text{Consts}$
  
  It is clear from the definition of $\text{Consts}$ that there is exactly one set $C = C_1 \cup C_2 \cup C_3$ such that $(t, C) \in \text{Consts}$.

This proves that $\text{Consts}$ is indeed a function.

But what about $\text{BadConsts}$? It is also a relation, but it isn't a function. For instance, $\text{BadConsts}(0) = \left\\{ 0 \right\\}$ and $\text{BadConsts}(0) = \left\\{ \right\\}$, which violates determinism. To reformulate this in terms of the above, there are two sets $C$ such that $(0, C) \in \text{BadConsts}$, namely $C = \left\\{ 0 \right\\}$ and $C = \left\\{ \right\\}$.

Note that there are many other problems with $\text{BadConsts}$, but this is sufficient to prove that it isn't a function.

The [week 2 slides](https://fos2018.github.io/slides/week02.pdf) have another example of a proof by induction, which I won't go into here.

### Operational semantics and reasoning

#### Evaluation
Suppose we have the following syntax

{% highlight antlr linenos %}
t ::=                  // terms
    true                   // constant true
    false                  // constant false 
    if t then t else t     // conditional
{% endhighlight %}

The evaluation relation $t \longrightarrow t'$ is the smallest relation closed under the following rules.

The following are *computation rules*, defining the "real" computation steps:

$$
\begin{align}
\text{if true then } t_2 \text{ else } t_3 \longrightarrow t_2 
\tag{E-IfTrue}
\label{eq:e-iftrue} \\

\text{if false then } t_2 \text{ else } t_3 \longrightarrow t_3 
\tag{E-IfFalse}
\label{eq:e-iffalse} \\
\end{align}
$$

The following is a *congruence rule*, defining where the computation rule is applied next:

$$
\frac{t_1 \longrightarrow t_1'}
     {\text{if } t_1 \text{ then } t_2 \text{ else } t_3 \longrightarrow \text{if } t_1' \text{ then } t_2 \text{ else } t_3} 
\tag{E-If}
\label{eq:e-if}
$$

We want to evaluate the condition before the conditional clauses in order to save on evaluation; we're not sure which one should be evaluated, so we need to know the condition first.

#### Derivations
We can describe the evaluation logically from the above rules using derivation trees. Suppose we want to evaluate the following (with parentheses added for clarity): `if (if true then true else false) then false else true`.

In an attempt to make all this fit onto the screen, `true` and `false` have been abbreviated `T` and `F` in the derivation below, and the `then` keyword has been replaced with a parenthesis notation for the condition.

$$
\frac{
    \frac{
        \text{if } (T) \text{ } T \text{ else } F
        \longrightarrow
        T
        \quad (\ref{eq:e-iftrue})
    }{
        \text{if } (\text{if } (T) \text{ } T \text{ else } F) \text{ } F \text{ else } T
        \longrightarrow
        \text{if } (T) \text{ } F \text{ else } T
        \quad (\ref{eq:e-if})
    }

    \qquad 

    \small{
        \text{if } (T) \text{ } F \text{ else } T
        \longrightarrow
        F
        \quad (\ref{eq:e-iftrue})
    }
}{
    \text{if } (\text{if } (T) \text{ } T \text{ else } F) \text{ } F \text{ else } T
    \longrightarrow
    T
}
$$

The final statement is a **conclusion**. We say that the derivation is a **witness** for its conclusion (or a **proof** for its conclusion). The derivation records all reasoning steps that lead us to the conclusion.

We can introduce the **inversion lemma**, which tells us how we got to a term. 

Suppose we are given a derivation $\mathcal{D}$ witnessing the pair $(t, t')$ in the evaluation relation. Then either:

1. If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iftrue})$, then we have $\text{if } true \text{ then } t_2 \text{ else } t_3$ and $t'=t_2$ for some $t_2$ and $t_3$
2. If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iffalse})$, then we have $\text{if } false \text{ then } t_2 \text{ else } t_3$ and $t'=t_2$ for some $t_2$ and $t_3$
3. If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-if})$, then we have $t = \text{if } t_1 \text{ then } t_2 \text{ else } t_3$ and $t' = t = \text{if } t_1' \text{ then } t_2 \text{ else } t_3$, for some $t_1, t_1', t_2, t_3$. Moreover, the immediate subderivation of $\mathcal{D}$ witnesses $(t_1, t_1') \in \longrightarrow$. 

This is super boring, but we do need to acknowledge the inversion lemma before we can do induction proofs on derivations. Thanks to the inversion lemma, given an arbitrary derivation $\mathcal{D}$ with conclusion $t \longrightarrow t'$, we can proceed with a case-by-case analysis on the final rule used in the derivation tree.

For instance, if we define $\text{size}(t)$ to be the i at which $\mathcal{S}_i$ describing it was created (so $\text{size}(true) = 1, \text{size}(\text{succ } t_1 = \text{size}(t_1) + 1$, etc.). We want to prove that if $t \longrightarrow t'$, then $\text{size}(t) > \text{size}(t')$.

1. If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iftrue})$, then we have $\text{if } true \text{ then } t_2 \text{ else } t_3$ and $t'=t_2$, and the result is immediate from the definition of $\text{size}$
2. If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-iffalse})$, then we have $\text{if } false \text{ then } t_2 \text{ else } t_3$ and $t'=t_2$, and the result is immediate from the definition of $\text{size}$
3. If the final rule applied in $\mathcal{D}$ was $(\ref{eq:e-if})$, then we have $t = \text{if } t_1 \text{ then } t_2 \text{ else } t_3$ and $t' = t = \text{if } t_1' \text{ then } t_2 \text{ else } t_3$. In this case, $t_1 \longrightarrow t_1'$ is witnessed by a derivation $\mathcal{D}_1$. By the induction hypothesis, $\text{size}(t_1) > \text{size}(t_1')$, and the result is then immediate from the definition of $\text{size}$

### Structural induction 
TODO

### Abstract machines
An abstract machine consists of:

- A set of **states**
- A **transition** relation of states, written $\longrightarrow$

$t \longrightarrow t'$ means that $t$ evaluates to $t'$ in one step. Note that $\longrightarrow$ is a relation, and that $t \longrightarrow t'$ is shorthand for $(t, t') \in \longrightarrow$. Often, this relation is a partial function (not necessarily covering the domain A; there is at most one possible next state). But without loss of generality, there may be many possible next states, determinism isn't a criterion here.

### Normal forms
A normal form is a term that cannot be evaluated any further. More formally, a term $t$ is a normal form if there is no $t'$ such that $t \longrightarrow t'$.  A normal form is a state where the abstract machine is halted; we can regard it as the result of a computation. 

#### Values that are normal form
Previously, we intended for our values (true and false) to be exactly that, the result of a computation. Did we get that right? 

Let's prove that a term $t$ is a value $\iff$ it is in normal form.

- The $\implies$ direction is immediate from the definition of the evaluation relation $\longrightarrow$.
- The $\impliedby$ direction is more conveniently proven as its contrapositive: if $t$ is not a value, then it is not a normal form, which we can prove by induction on the term $t$.

  Since $t$ is not a value, it must be of the form $\text{if } t_1 \text{ then } t_2 \text{ else } t_3$. If $t_1$ is directly `true` or `false`, then E-IfTrue or E-IfFalse apply, and we are done.

  Now, if $t$ is an if-then-else, and $t_1$ isn't a value, by the induction hypothesis, there is a $t_1'$ such that $t_1 \longrightarrow t_1'$. Then rule E-If yields $\text{if } t_1' \text{ then } t_2 \text{ else } t_3$, which proves that $t$ is not in normal form.


#### Values that are not normal form
Let's introduce new syntactic forms, with new evaluation rules.

{% highlight antlr linenos %}
t ::=        // terms
    0            // constant 0
    succ t       // successor
    pred t       // predecessor 
    iszero t     // zero test

v ::=  nv     // values

nv ::=        // numeric values
    0             // zero value
    succ nv       // successor value
{% endhighlight %}

The evaluation rules are given as follows:

$$
\begin{align}
& \frac{t_1 \longrightarrow t_1'}{\text{succ } t_1 \longrightarrow \text{succ } t_1'} 
\tag{E-Succ} \label{eq:e-succ}
\\ \\
& \text{pred } 0 \longrightarrow 0
\tag{E-PredZero} \label{eq:e-predzero} 
\\ \\
& \text{pred succ } nv_1 \longrightarrow nv_1
\tag{E-PredSucc} \label{eq:e-predsucc}
\\ \\
& \frac{t_1 \longrightarrow t_1'}{\text{pred } t_1 \longrightarrow \text{pred } t_1'}
\tag{E-Pred} \label{eq:e-pred}
\\ \\
& \text{iszero } 0 \longrightarrow true
\tag{E-IszeroZero} \label{eq:e-iszerozero}
\\ \\
& \text{iszero succ } nv_1 \longrightarrow false
\tag{E-IszeroSucc} \label{eq:e-iszerosucc}
\\ \\
& \frac{t_1 \longrightarrow t_1'}{\text{iszero } t_1 \longrightarrow \text{iszero } t_1'}
\tag{E-Iszero} \label{eq:e-iszero} \\
\end{align}
$$

All values are still normal forms. But are all normal forms values? Not in this case. For instance, `succ true`, `iszero true`, etc, are normal forms. These are **stuck terms**: they are in normal form, but are not values. In general, these correspond to some kind of type error, and one of the main purposes of a type system is to rule these kinds of situations out.

### Multi-step evaluation
Let's introduce the *multi-step evaluation* relation, $\longrightarrow^*$. It is the reflexive, transitive closure of single-step evaluation, i.e. the smallest relation closed under these rules:

$$
\frac{t\longrightarrow t'}{t \longrightarrow^* t'} \\ \\
t \longrightarrow^* t \\ \\
\frac{t \longrightarrow^* t' \qquad t' \longrightarrow^* t''}{t \longrightarrow^* t''}
$$

In other words, it corresponds to any number of single consecutive evaluations.

### Termination of evaluation
We'll prove that evaluation terminates, i.e. that for every term $t$ there is some normal form $t'$ such that $t\longrightarrow^* t'$.

First, let's recall our proof that $t\longrightarrow t' \implies \text{size}(t) > \text{size}(t')$. Now, for our proof by contradiction, assume that we have an infinite-length sequence $t_0, t_1, t_2, \dots$ such that:

$$
t_0 \longrightarrow t_1 \longrightarrow t_2 \longrightarrow \dots
\implies
\text{size}(t_0) > \text{size}(t_1) > \text{size}(t_2) > \dots
$$

But this sequence cannot exist, which is a contradiction. 

Most termination proofs have the same basic form. We want to prove that the relation $R\subseteq X \times X$ is terminating &mdash; that is, there are no infinite sequences $x_0, x_1, x_2$ etc. such that $(x_i, x_{i+1}) \in R$ for each $i$. We proceed as follows:

1. Choose a well-suited set $W$ with partial order $<$ such that there are no infinite descending chains $w_0 > w_1 > w_2 > \dots$ in $W$. Also choose a function $f: X \rightarrow W$.
2. Show $f(x) > f(y) \quad \forall (x, y) \in R$
3. Conclude that are no infinite sequences $(x_0, x_1, x_2, \dots)$ such that $(x_i, x_{i+1}) \in R$ for each $i$. If there were, we could construct an infinite descending chain in $W$.

As a side-note, **partial order** is defined as the following properties:

1. **Anti-symmetry**: $\neg(x < y \land y < x)$
2. **Transitivity**: $x<y \land y<z \implies x < z$

We can add a third property to achieve **total order**, namely $x \ne y \implies x <y \lor y<x$.

## Lambda calculus
Lambda calculus is Turing complete, and is higher-order (functions are data). In lambda calculus, all computation happens by means of function abstraction and application.

Lambda calculus is isomorphic to Turing machines. 

Suppose we wanted to write a function `plus3` in our previous language:

{% highlight linenos %}
plus3 x = succ succ succ x
{% endhighlight %}

The way we write this in lambda calculus is:

$$
\text{plus3 } = \lambda x. \text{ succ}(\text{succ}(\text{succ}(x)))
$$

$\lambda x. t$ is written `x => t` in Scala, or `fun x -> t` in OCaml. Application of our function, say `plus3(succ 0)`, can be written as:

$$
(\lambda x. \text{succ succ succ } x)(\text{succ } 0)
$$

Abstraction over functions is possible using higher-order functions, which we call $\lambda$-abstractions. An example of such an abstraction is the function $g$ below, which takes an argument $f$ and uses it in the function position. 

$$
g = \lambda f. f(f(\text{succ } 0))
$$

If we apply $g$ to an argument like $\text{plus3}$, we can just use the substitution rule to see how that defines a new function.

Another example: the double function below takes two arguments, as a curried function would. First, it takes the function to apply twice, then the argument on which to apply it, and then returns $f(f(y))$.

$$
\text{double} = \lambda f. \lambda y. f(f(y))
$$

### Pure lambda calculus
Once we have $\lambda$-abstractions, we can actually throw out all other language primitives like booleans and other values; all of these can be expressed as functions, as we'll see below. In pure lambda-calculus, *everything* is a function.

Variables will always denote a function, functions always take other functions as parameters, and the result of an evaluation is always a function.

The syntax of lambda-calculus is very simple:

{% highlight antlr linenos %}
t ::=      // terms, also called Î»-terms
    x         // variable
    Î»x. t     // abstraction, also called Î»-abstractions
    t t       // application
{% endhighlight %}

A few rules and syntactic conventions:

- Application associates to the left, so $t\ u\ v$ means $(t\ u)\ v$, not $t\ (u\ v)$.
- Bodies of lambda abstractions extend as far to the right as possible, so $\lambda x. \lambda y. x\ y$ means $\lambda x. (\lambda y. x\ y)$, not $\lambda x. (\lambda y. x)\ y$

#### Scope
The lambda expression $\lambda x. t$ **binds** the variable $x$, with a **scope** limited to $t$. Occurrences of $x$ inside of $t$ are said to be *bound*, while occurrences outside are said to be *free*. 

#### Operational semantics
As we saw with our previous language, the rules could be distinguished into *computation* and *congruence* rules. For lambda calculus, the only computation rule is:

$$
(\lambda x. t_{12}) v_2 \longrightarrow \left[ x \mapsto v_2 \right] t_{12}
\tag{E-AppAbs}\label{eq:e-appabs}
$$

The notation $\left[ x \mapsto v_2 \right] t_{12}$ means "the term that results from substituting free occurrences of $x$ in $t_{12}$ with $v_2$".

The congruence rules are:

$$
\begin{align}
& \frac{t_1 \longrightarrow t_1'}{t_1 t_2 \longrightarrow t_1' t_2} \tag{E-App1}\label{eq:e-app1} \\ \\
& \frac{t_2 \longrightarrow t_2'}{t_1 t_2 \longrightarrow t_1 t_2'} \tag{E-App2}\label{eq:e-app2} \\
\end{align}
$$

A lambda-expression applied to a value, $(\lambda x. t)\ v$, is called a **reducible expression**, or **redex**.

#### Evaluation strategies
There are alternative evaluation strategies. In the above, we have chosen call by value (which is the standard in most mainstream languages), but we could also choose:

- **Full beta-reduction**: any redex may be reduced at any time. This offers no restrictions, but in practice, we go with a set of restrictions like the ones below (because coding a fixed way is easier than coding probabilistic behavior).
- **Normal order**: the leftmost, outermost redex is always reduced first. This strategy allows to reduce inside unapplied lambda terms
- **Call-by-name**: allows no reductions inside lambda abstractions. Arguments are not reduced before being substituted in the body of lambda terms when applied. Haskell uses an optimized version of this, call-by-need (aka lazy evaluation).

### Classical lambda calculus
Classical lambda calculus allows for full beta reduction. 

#### Confluence in full beta reduction
The congruence rules allow us to apply in different ways; we can choose between $\ref{eq:e-app1}$ and $\ref{eq:e-app2}$ every time we reduce an application, and this offers many possible reduction paths. 

While the path is non-deterministic, is the result also non-deterministic? This question took a very long time to answer, but after 25 years or so, it was proven that the result is always the same. This is known the **Church-Rosser confluence theorem**:

Let $t, t_1, t_2$ be terms such that $t \longrightarrow^* t_1$ and $t \longrightarrow^* t_2$. Then there exists a term $t_3$ such that $t_1 \longrightarrow^* t_3$ and $t_2 \longrightarrow^* t_3$

#### Alpha conversion
Substitution is actually trickier than it looks! For instance, in the  expression $\lambda x.\ (\lambda y.\ x)\ y$, the first occurrence of $y$ is bound, while the second is free. This is comparable to scope in most programming languages, where we should understand that these are two different variables, $y_1$ and $y_2$.

The above example had a variable that is both bound and free, which is something that we'll try to avoid. This is called a hygiene condition.

We can transform a unhygienic expression to a hygienic one by renaming bound variables before performing the substitution. This is known as **alpha conversion**.

Let $\text{fv}(t)$ be the set of free variables in a term $t$. Alpha conversion is given by the following conversion rule:

$$
\frac{y \notin \text{fv}(t)}{(\lambda x.\ t) =_\alpha (\lambda y.\ \left[ x\mapsto y\right]\ t)}
\tag{$\alpha$}
\label{eq:alpha-conv}
$$

And these equivalence rules (in mathematics, equivalence is defined as symmetry and transitivity):

$$
\begin{align}
\frac{t_1 =_\alpha t_2}{t_2 =_\alpha t_1} 
\tag{$\alpha \text{-Symm}$}
\label{eq:alpha-sym}
\\ \\

\frac{t_1 =_\alpha t_2 \quad t_2 =_\alpha t_3}{t_1 =_\alpha t_3}
\tag{$\alpha \text{-Trans}$}
\label{eq:alpha-trans}
\\
\end{align}
$$

The congruence rules are as usual.

### Programming in lambda-calculus

#### Multiple arguments
The way to handle multiple arguments is by currying: $\lambda x.\ \lambda y.\ t$

#### Booleans
The fundamental, universal operator on booleans is if-then-else, which is what we'll replicate to model booleans. We want `true` to be equivalent to `if (true)`, and `false` to `if (false)`.

$$
\begin{align}
\text{tru } & = \lambda t.\ \lambda f.\ t \\
\text{fls } & = \lambda t.\ \lambda f.\ f \\
\end{align}
$$

We can consider these as booleans. Equivalently `tru` can be considered as a function performing `(t1, t2) => if (true) t1 else t2`. To understand this, let's try to apply $\text{tru}$ to two arguments:

$$
\begin{align}
&   && \text{tru } v\ w \\
& = && (\lambda t.\ (\lambda f.\ \lambda t))\ v\ w \\
& \longrightarrow && (\lambda f.\ v)\ w \\
& \longrightarrow && v \\
\end{align}
$$

This works equivalently for `fls`. 

We can also do inversion, conjunction and disjunction with lambda calculus:

$$
\begin{align}
\text{not } & = \lambda b.\ b\ \text{fls}\ \text{true} \\
\text{and } & = \lambda b.\ \lambda c.\ b\ c\ \text{fls} \\
\text{or }  & = \lambda b.\ \lambda c.\ b\ \text{tru}\ c \\
\end{align}
$$


- `not` is a function that is equivalent to `not(b) = if (b) false else true`. 
- `and` is equivalent to `and(b, c) = if (b) c else false`
- `or` is equivalent to `or(b, c) = if (b) true else c`

#### Pairs
The fundamental operations are construction `pair(a, b)`, and selection `pair._1` and `pair._2`.

$$
\begin{align}
\text{pair } & = \lambda f.\ \lambda s.\ \lambda b.\ b\ f\ s\\
\text{fst }  & = \lambda p.\ p\ \text{tru} \\
\text{snd }  & = \lambda p.\ p\ \text{fls} \\
\end{align}
$$

- `pair` is equivalent to `pair(f, s) = (b => b f s)`
- When `tru` is applied to `pair`, it selects the first element, by definition of the boolean, and that is therefore the definition of `fst`
- Equivalently for `fls` applied to `pair`, it selects the second element

#### Numbers
We've actually been representing numbers as lambda-calculus numbers all along! Our `succ` function represents what's more formally called **Church numerals**.

$$
\begin{align}
c_0 & = \lambda s.\ \lambda z.\ z \\
c_1 & = \lambda s.\ \lambda z.\ s\ z \\
c_2 & = \lambda s.\ \lambda z.\ s\ s\ z \\
c_3 & = \lambda s.\ \lambda z.\ s\ s\ s\ z \\
\end{align}
$$

Every number $n$ is represented by a term $c_n$ taking two arguments, $s$ and $z$ (for "successor" and "zero"), and applies $s$ to $z$, $n$ times.